var tipuesearch = {"pages":[{"title":"About","text":"I am a chilean professor working at Universidad de los Andes in the Faculty of Engineering and Applied Sciences . My main research focuses on the study of structure-soil systems under earthquake loading, through modeling and simulation. An important aspect of my research is that I place strong emphasis on the correct description of seismic wave propagation from source to site. A major goal for me is to leverage the use of high-performance computing as the enabling technology that will allow the profession to move forward in terms of the power of analysis available to engineers. See also : Extended research statement . Publications . Teaching . Curriculum Vitae . Interesting Links . Information for Prospective Students .","tags":"pages","url":"https://joseabell.com/pages/01about.html","loc":"https://joseabell.com/pages/01about.html"},{"title":"Publications","text":"Google Scholar 0000-0002-2735-6547 Journal Articles Click to get details! [ Accepted ] M. Birrell, C. Pastén, J.A. Abell , R. Astroza , Probabilistic characterization of a high-cycle accumulation model for sands, Computers and Geotechnics, Volume 147, 2022, https://doi.org/10.1016/j.compgeo.2022.104798 . Abstract In this paper, we employ a Bayesian approach to estimate the parameters of a high cycle accumulation model for sands using experimental data. Global sensitivity analysis and Markov-Chain Monte Carlo simulation are conducted for each of the twenty-four available experimental drained triaxial test results, considering the effect of estimating soil parameters at each strain-cycle under several loading conditions. Probability distributions inferred from each data source are then combined to obtain a single distribution for model parameters. Model calibration is then validated against new observations. The accumulated strain model is calibrated through explicit computation of strain at each cycle and the strain dependence of model parameters is included through the cyclic variation of the model constants. [PDF] [BLOG] [ In review ] Marco Tulio Herrera, Jorge G. F. Crempien , Roberto Benavente, Jose A. Abell. Bayesian ground motion model selection method based on evidence and information criteria . Bulletin of the Seismological Society of America Abstract Quicumque vult salvus esse, ante omnia opus est, ut teneat catholicam fidem: Quam nisi quisque integram inviolatamque servaverit, absque dubio in aeternum peribit. Fides autem catholica haec est: ut unum Deum in Trinitate, et Trinitatem in unitate veneremur. Neque confundentes personas, neque substantiam separantes. Alia est enim persona Patris alia Filii, alia Spiritus Sancti: Sed Patris, et Filii, et Spiritus Sancti una est divinitas, aequalis gloria, coeterna maiestas. Qualis Pater, talis Filius, talis Spiritus Sanctus. Increatus Pater, increatus Filius, increatus Spiritus Sanctus. Immensus Pater, immensus Filius, immensus Spiritus Sanctus. Aeternus Pater, aeternus Filius, aeternus Spiritus Sanctus. Et tamen non tres aeterni, sed unus aeternus. Sicut non tres increati, nec tres immensi, sed unus increatus, et unus immensus. Similiter omnipotens Pater, omnipotens Filius, omnipotens Spiritus Sanctus. Et tamen non tres omnipotentes, sed unus omnipotens. Ita Deus Pater, Deus Filius, Deus Spiritus Sanctus. Et tamen non tres dei, sed unus est Deus. Ita Dominus Pater, Dominus Filius, Dominus Spiritus Sanctus. Et tamen non tres Domini, sed unus est Dominus. Haec est fides catholica, quam nisi quisque fideliter firmiterque crediderit, salvus esse non poterit. [PDF] [BLOG] [ Accepted ] Francisco J. Pinto, Christian Ledezma, Jose A. Abell. , Rodrigo Astroza , Shideh Dashti Soil-Basement Interaction Effects on the Seismic Response of Tall Buildings with Basement Levels . Engineering structures Abstract The need to build tall buildings has been increasing worldwide, creating new challenges in earthquake engineering and design. Many of the current analysis methods cannot be extrapolated beyond the definition under which they were established. Prior studies and existing seismic design guidelines have indicated that the current fixed-base hypothesis for evaluating the seismic response of structures is not sufficient to properly represent the boundary conditions and behavior of tall buildings with basement levels. Studies of soil-structure interaction (SSI) for tall buildings have, however, typically been inconclusive. It is not clear under which conditions consideration of soil-basement-structure interaction (SBSI) is necessary for the design of the superstructure, foundation, and basement levels and when it can safely be avoided. Given the rising demand, it is essential to evaluate the relation of global system variables such as the basement depth, structure height, and soil characteristics with the building's response via numerical and experimental modeling. Therefore, an experimental-numerical approach is presented to better understand the seismic response of tall buildings with basement levels, considering explicit SBSI modeling. Chilean tall buildings and soil conditions are used as study cases, analyzed using non-linear finite element analyses in conjunction with results from centrifuge experiments. The results show how seismic response parameters and modals characteristics, such as inter-story drifts, shear force, bending moment, natural frequencies and damping ratios, change when SBSI is appropriately incorporated. The results point to the importance of considering soil-basement-interaction effects to evaluate the seismic response of tall buildings with basement levels and avoid unsafe estimations or the need for overdesign. [PDF] [BLOG] [ In review ] Francisco Pinto, Shideh Dashti, Christian Ledezma, Jose A. Abell. How Do Tall Buildings Affect Seismic Earth Pressures on Their Basement Walls? . Soil Dynamics and Earthquake Engineering ![Fig 1]( Abstract Construction of tall buildings has recently gone through an exponential growth in major cities, creating new challenges in earthquake engineering and design. For instance, existing analytical procedures for evaluating seismic lateral earth pressures on basement walls that are connected to these buildings typically ignore the inertia and dynamic properties of the superstructure. The inertial forces from a tall superstructure may cause additional displacements and rotations in its basement that would affect the distribution and magnitude of seismic lateral earth pressures. These additional soil- basement-structure interaction (SBSI) effects are currently not well understood. Hence, the applicability and reliability of existing procedures to the basements of tall buildings remains questionable. In this paper, we use an experimental-numerical approach to provide insight on how the lateral resisting system of tall superstructures may impact the magnitude and distribution of seismic earth pressures on basement walls buried in dry sand and gravel. Numerical simulations are first validated in 3D using a prior centrifuge experiment that included a simplified model of a 42-story, highrise structure in medium-dense, dry sand. Then, the numerical tool is used to perform 156, 2D, nonlinear simulations of more realistic buildings and basements, ground motion characteristics, as well as both sandy and gravely soil profiles. Nonlinear numerical simulations are shown to successfully capture the building's inertial and kinematic seismic interactions with the basement and an adjacent underground structure. The subsequent numerical sensitivity study showed that inertial forces from a tall superstructure increase total lateral earth pressures on the basement walls. This increase is particularly notable in the top two-thirds of the basement wall and can be approximated by a trapezoidal distribution. The superstructure's inertia amplifies the seismic earth pressure increments at shallow depths, with an approximately inverted triangular shape. These effects and reliability of existing analytical procedures are shown to be highly sensitive to the building's modal frequencies in relation to the frequency content of the input motion as well as the stiffness of the structure-basement system in relation to the underlying soil. The results point to the importance of considering the building's dynamic properties and inertia in evaluation of seismic earth pressures on basement walls, in order to avoid unsafe estimations or the need for overdesign. [PDF] [BLOG] [ Accepted ] Jose A. Abell. , Jorge G.F. Crempien , Matías Recabarren ShakerMaker : A framework that simplifies the simulation of seismic ground-motions . SoftwareX Abstract ShakerMaker is an open-source python framework which simplifies the generation of synthetic broad-band seismograms, produced by finite-fault kinematic representations of earthquake ruptures, using a 1-D layered model of the crust and the frequency-wavenumber ( \\(f\\) – \\(k\\) ) method. It is designed to bring closer the engineering seismology and earthquake engineering communi- ties, by catering to the earthquake simulation needs of both disciplines. One particular goal of this framework is to provide a simple way to produce high- fidelity earthquake motions for use with the domain-reduction method, sim- plifying the setup of physically accurate finite-element simulations of multi- scale seismological and earthquake engineering problems through the use of a new specialized file format. ShakerMaker 's core is composed of a high-performance Fortran imple- mentation of the \\(f\\) - \\(k\\) method, that is exposed to the user as a python frame- work. Its software architecture emphasizes simplicity, extensibility, and per- formance, allowing users to specify complex simulation scenarios with short scripts. The message passing interface is used to achieve scalability from simple single-processor machines to HPC clusters. [PDF] [BLOG] [ Accepted ] Francisco Pinto, Christian Ledezma, Rodrigo Astroza, Jose A. Abell. Modeling the loss of vibration energy in buildings to elastic-waves using high-fidelity FE modeling and absorbent exterior boundaries . Journal of Earthquake Engineering. Abstract The modeling of structural damping due to the excitation of elastic-waves into the surrounding soil domain, and its effect on structural response as apparent modal damping is explored herein. Four high-fidelity, linear finite-element mod- els of building-site systems, with 20 to 50 storeys and 2 to 7 basement levels, are simulated in OpenSees to evaluate their frequency response. Radiation-damping is provided by a layer of high-damping elements, which design is explored in detail. Results show that up to 1% of apparent, low-amplitude damping can be attributed to radiation-damping depending on number of stories and depth of embedment. [PDF] [BLOG] [ Accepted ] Haoyuan Liu, Evangelos Kementzetzidis, José Antonio Abell , Federico Pisanò From cyclic sand ratcheting to tilt accumulation in offshore monopiles: 3D FE modelling using SANISAND-MS . Géotechnique. Online March 8, 2021 (Ahead of print) Abstract The modeling of structural damping due to the excitation of elastic-waves into the surrounding soil domain, and its effect on structural response as apparent modal damping is explored herein. Four high-fidelity, linear finite-element mod- els of building-site systems, with 20 to 50 storeys and 2 to 7 basement levels, are simulated in OpenSees to evaluate their frequency response. Radiation-damping is provided by a layer of high-damping elements, which design is explored in detail. Results show that up to 1% of apparent, low-amplitude damping can be attributed to radiation-damping depending on number of stories and depth of embedment. [PDF] [BLOG] Nicolás Andrés Galano, Patricio Alejandro Moreno-Casas , Jose Antonio Abell . Extending the Particle Finite Element Method for Sediment Transport Simulation . Computer Methods in Applied Mechanics and Engineering, Vol 380, 1 July 2021. Abstract The present work extends the capabilities of the Particle Finite Element Method (PFEM), which allows modeling of soil-fluid-structure interaction problems, to allow the modeling of sediment transport and scouring effects. This is accomplished by implementing scouring rules on an evolving scourable-interface, i.e. the interface surface between fluid and soil. The proposed method improves upon previous proposals by jointly capturing both the temporal and spatial scales of scouring evolution, as shown in the presented validation exercise, and also because its parametrization is conforms with commonplace engineering procedures for scouring prediction. The extension preserves desirable PFEM properties such as conservation of mass, mesh-size independence, and stability of the numerical solution of the PFEM equations. [PDF] [BLOG] Haoyuan Liu, Andrea Diambra , José Antonio Abell , Federico Pisanò . Memory-enhanced plasticity modelling of sand behaviour under undrained cyclic loading . Journal of Geotechnical and Geoenvironmental Engineering, Vol. 146, Issue 11 (November 2020) Abstract This work presents a critical state plasticity model for predicting the response of sands to cyclic loading. The well-known bounding surface SANISAND framework by Dafalias & Manzari (2004) is enhanced with a `memory surface' to capture micro-mechanical, fabric-related processes directly effecting cyclic sand behaviour. The resulting model, SANISAND-MS, was recently proposed by Liu et al. (2019) , and successfully applied to the simulation of drained sand ratcheting under thousands of loading cycles. Herein, novel ingredients are embedded into Liu et al. (2019) 's formulation to better capture the effects of fabric evolution history on sand stiffness and dilatancy. The new features enable remarkable accuracy in simulating undrained pore pressure build-up and cyclic mobility behaviour in medium-dense/dense sand. The performance of the upgraded SANISAND-MS is validated against experimental test results from the literature - including undrained cyclic triaxial tests at varying cyclic loading conditions and pre-cyclic consolidation histories. The proposed modelling platform will positively impact the study of relevant cyclic/dynamic problems, for instance, in the fields of earthquake and offshore geotechnics. [PDF] [BLOG] Patricio A. Moreno-Casas , Felipe Scott , José Delpiano , José A. Abell , Francisco Caicedo, Raúl Muñoz, and Alberto Vergara-Fernández . Mechanistic Description of Convective Gas–Liquid Mass Transfer in Biotrickling Filters Using CFD Modeling. Environmental Science & Technology 2020 54 (1), 419-426 Abstract The gas−liquid mass transfer coefficient is a key parameter to the design and operation of biotrickling filters that governs the transport rate of contaminants and oxygen from the gas phase to the liquid phase, where pollutant biodegradation occurs. Mass transfer coefficients are typically estimated via experimental procedures to produce empirical correlations, which are only valid for the bioreactor configuration and range of operational conditions under investigation. In this work, a new method for the estimation of the gas−liquid mass transfer coefficient in biotrickling filters is presented. This novel methodology couples a realistic description of the packing media (polyurethane foam without a biofilm) obtained using microtomography with computational fluid dynamics. The two-dimensional analysis reported in this study allowed capturing the mechanisms of the complex processes involved in the creeping porous air and water flow in the presence of capillary effects in biotrickling filters. Model predictions matched the experimental mass transfer coefficients (±30%) under a wide range of operational conditions. [ PDF ] [BLOG] Hao Yuan Liu, José Antonio Abell , Andrea Diambra , and Federico Pisanò. Modelling the cyclic ratcheting of sands through memory-enhanced bounding surface plasticity. Géotechnique 2019 69:9, 783-800 Abstract The modelling and simulation of cyclic sand ratcheting is tackled via a plasticity model formulated withinthe well-known critical state, bounding surface SANISAND framework. For this purpose, a third locus –termed ‘memory surface' – is cast into the constitutive formulation, so as to phenomenologically capturemicro-mechanical, fabric-related processes directly relevant to the cyclic response. The predictive capabilityof the model under numerous loading cycles (‘high-cyclic' loading) is explored with focus on drainedloading conditions, and validated against experimental test results from the literature – including triaxial,simple shear and oedometer cyclic loading. The model proves capable of reproducing the transition fromratcheting to shakedown response, in combination with a single set of soil parameters for different initial,boundary and loading conditions. This work contributes to the analysis of soil-structure interaction underhigh-cyclic loading events, such as those induced by environmental and/or traffic loads. [ PDF ] [ BLOG ] José. A. Abell , Nebojša Orbović, David B. McCallen and Boris Jeremić . Earthquake Soil Structure Interaction of Nuclear Power Plants, differences in response to 3-D, 3×1-D, and 1-D excitations. Earthquake Engineering and Structural Dynamics, in print, 2018. In soil-structure interaction modeling of systems subjected to earthquake motions, it is classically assumed that the incoming wave field, produced by an earthquake, is unidimensional and vertically propagating. This work explores the validity of this assumption by performing earthquake soil-structure interaction modeling, including explicit modeling of sources, seismic wave propagation, site, and structure. The domain reduction method is used to couple seismic (near-field) simulations with local soil-structure interaction response. The response of a generic nuclear power plant model computed using full earthquake soil-structure interaction simulations is compared with the current state-of-the-art method of deconvolving in depth the (simulated) free-field motions, recorded at the site of interest, and assuming that the earthquake wave field is spatially unidimensional. Results show that the 1-D wave-field assumption does not hold in general. It is shown that the way in which full 3-D analysis results differ from those which assume a 1-D wave field is dependent on fault-to-site geometry and motion frequency content. It is argued that this is especially important for certain classes of soil-structure systems of which nuclear power plants subjected to near-field earthquakes are an example. [ PDF ] [ BLOG ] Catalina Fortuño, Juan Carlos de la Llera , Charles W. Wicks , and José A. Abell - Synthetic Hybrid Broadband Seismograms Based on InSAR Coseismic Displacements . Bulletin of the Seismological Society of America published ahead of print November 18, 2014, doi:10.1785/0120130293 Abstract Conventional acceleration records do not properly account for the observed coseismic ground displacements, thus leading to an inaccurate definition of the seismic demand needed for the design of flexible (long-period) structures. Large coseismic displacements observed during the Feb 27, 2010, Maule earthquake, suggest that this effect should be included in the design of flexible structures by modifying the design ground-motions and spectra considered. Consequently, Green's Functions are used herein to compute synthetic low-frequency seismograms that are consistent with the coseismic displacement field obtained from interferometry using synthetic aperture radar images. In this case, the coseismic displacement field was determined by interfering twenty SAR images of the ALOS-PALSAR satellite taken between 10/12/2007 and 05/28/2010. These images cover the region affected by the M w 8.8 2010, Maule earthquake. Synthetic broadband seismograms are built by superimposing the low-pass filtered synthetic low-frequency seismograms with high-frequency strong-motion data. The broadband seismograms generated are then consistent with the coseismic displacement field and the high-frequency content of the earthquake. A sensitivity analysis is performed using three different fault and slip parameters, the rupture velocity, the corner frequency, and the slip rise time. Results show that the optimal corner frequency of the low-pass filter \\(f_c = 1/T_c\\) , leads to a trade-off between acceleration and displacement accuracy. Furthermore, spectral response for long periods, say \\(T \\ge 8s\\) , is relatively insensitive to the value of \\(T_c\\) , while shorter periods are strongly dependent on both, the slip rise time and \\(T_c\\) . In general, larger displacements consistent with coseismic data are obtained using this technique instead of digitally processing the acceleration ground-motion records. [ PDF ] [[BLOG]] José A. Abell , Juan Carlos de la Llera , Charles W. Wicks - Enhancement of long period components of recorded and synthetic ground motions using InSAR . Soil Dynamics and Earthquake Engineering 01/2011; 31(5):817-829 . DOI:10.1016/j.soildyn.2011.01.005 Abstract Tall buildings and flexible structures require a better characterization of long period ground motion spectra than the one provided by current seismic building codes. Motivated by that, a methodology is proposed and tested to improve recorded and synthetic ground motions which are consistent with the observed co-seismic displacement field obtained from interferometric synthetic aperture radar (InSAR) analysis of image data for the Tocopilla 2007 earthquake ( \\(M_w=7.7\\) ) in Northern Chile. A methodology is proposed to correct the observed motions such that, after double integration, they are coherent with the local value of the residual displacement. Synthetic records are generated by using a stochastic finite-fault model coupled with a long period pulse to capture the long period fling effect.It is observed that the proposed co-seismic correction yields records with more accurate long-period spectral components as compared with regular correction schemes such as acausal filtering. These signals provide an estimate for the velocity and displacement spectra, which are essential for tall-building design. Furthermore, hints are provided as to the shape of long-period spectra for seismic zones prone to large co-seismic displacements such as the Nazca-South American zone. [ PDF ] [[BLOG]] Conference Proceedings Please check my ResearchGate profile for the most up-to-date list of conference papers. Yuan Feng, José Abell , Sumeet Kumar Sinha, Han Yang, Fatemah Behbehani, Hexian Wang, Nebojša Orbović, David B McCallen and Boris Jeremić . Verification for the Real ESSI Simulator . In proceedings of Structural Mechanics in Reactor Technology (SMiRT) 24 conference, Busan, South Korea, August 20-25, 2017. J. A. Abell , J. G. F. Crempien , and B. Jeremić - Physics-Based Scenario Modeling for Earthquake-Soil-Structure Interaction of Buildings in Proceedings of the 16th. World Conference on Earthquake Engineering, 2017. José Antonio Abell Mena , Sumeet Kumar Sinha, Boris Jeremić - Wavelet Based Synthetic Earthquake Sources for Path and Soil Structure Interaction Modeling: Stress Testing of Nuclear Power Plants Proceedings of IAEA conference on: Best Practices in Physics-based Fault Rupture Models for Seismic Hazard Assessment of Nuclear Installations, Vienna, Austria, November 1820, 2015 Nebojša Orbović, Boris Jeremić , José Antonio Abell Mena , Chao Luo, Robert P. Kennedy and Andrei Blaihoanu - Use of Nonlinear, Time Domain Analysis for Design of NPPs in Proceedings of the Structural Mechanics in Reactor Technology (SMiRT) 2015 Conference, Manchester, August 10-14, 2015. N.Tafazzoli, F. Pisanò , J. A. Abell M. , B. Kamrani, C.-G. Jeong, B. Aldridge, R. Roche, A. Kammerer, and B. Jeremic - * ESSI Simulator Program, Current Status* . Proceedings of the 22nd. Structural Mechanics in Reactor Technology (SMiRT 22) Conference, San Francisco, California, U.S.A. Ph.D. Dissertation Earthquake-Soil-Structure Interaction Modeling of Nuclear Power Plants for Near-Field Events - Ph.D. Dissertation - University of California at Davis, March 2016 Masters Thesis InSAR Compatible Ground Motions for Northern Chile - Masters Thesis - Pontificia Universidad Católica de Chile, August 2009","tags":"pages","url":"https://joseabell.com/pages/04publications.html","loc":"https://joseabell.com/pages/04publications.html"},{"title":"Tools","text":"Tools I've (Cr)eated/(Co)ntributed to OpenSees - (Co) UC Berkeley RealESSI Simulator - (Co) UCD Earthquake-Soil-Structure Interaction simulator system. FEI-Syntax-n-Snippets - (Cr) - Syntax highlighter and snippets for the Finite Element Interpreter (A domain specific language for FEA modelling within ESSI Simulator). visitESSI - (Cr) - A plugin for visualizing ESSI Simulator HDF5 output. gmshtranslator - (Cr) - A python parser for gmsh .msh format. I use it to create ESSI/OpenSees/whateverelse models. 3rd. Party tools I strive to stay as open source/free as I can with the tools I use. Every now and then, though, I will pay for a useful tool. Here is a set of apps I love to use day to day. Special thanks to their creators. Sublime Text - A very cool text editor. (Free to try, but have to buy to keep using) SciPy - Scientific computing for Python. The reason I switched from Matlab to Python! Mendeley - Oh how would I ever manage references without you dear mendeley? Code::Blocks - Open source, very powerful IDE for C++ projects. gmsh - Need to generate 3D FEM meshes? gmsh will do that and more. STLfilt - A filter for compiler output. Very useful when dealing with STL and template metaprogramming. Makes reading error reports very easy. LTensor - A high performance C++ library for dealing with tensors (up to rank 4) based on templates. Deal with tensors in C++ using natural notation ! ARM Forge - A parallel-debugger/profiler suite. There is really no open-source alternative that can provide the productivity these guys provide. Costly though. Inkscape - My dark alternate identity, a designer. Useful vector graphics editor to create beautiful illustrations. I also (cr)eated a syntax highlighter and \"snippets\" package for this editor for our FEI Finite Element simulation program (ESSI) [ here ]. Can be installed easily into sublime with Package Control plugin (FEI-syntax-n-snippets). Spyder - A very cool, Matlab inspired, python editor for scientific computing. I don't use this anymore, it was a catalyst for my transition from matlab to python. I do recommend it to my students and matlab-based colleagues. GIMP - The Gnu Image Manipulation Program. My designer side flourishing again. Blender - Used for cool 3-D viz and random art I do. As far as OSes go Ubuntu - What? There are other Linux distributions out there? elementary OS - Interesting and pretty Ubuntu-based linux distro. Inspired by mac. Virtual Box - Because sometimes you just need windows (because other people can't linux). Some useful commands .","tags":"pages","url":"https://joseabell.com/pages/05tools.html","loc":"https://joseabell.com/pages/05tools.html"},{"title":"EOSD2022 Recap","text":"The Eurasian OpenSees days 2022 conference was a lot of fun! Especially because I had the opportunity to go with two students: Omar Oyarce and Alberto Hurtado (shown in the picture above with professor Pedro Arduino from University of Washington, Seattle) and show them what this little academic niche is all about. Also, I had the honor of being invited to give a keynote lecture! This is my first one, and I really hope I could get some of my research ideas across, despite taking to much of my audiences tme. I talked about my current research grant objectives and how some new available tools in OpenSees (and the jungle around OpenSees), together with my new HPC cluster make it possible. Here is a pic from the keynote. I'd like to reiterate and make public my gratitude towards the organizers for selecting me for this. I also gave a talk on my former student Felipe Elgueta's implementation of isogeometric analysis of shells in OpenSees and his thesis work. We got to hang out with well established professors such as Enrico Spacone, Guido Camata, and Pedro Arduino. And also meet the new, rising stars in the OpenSees world: Davide Gorini, Fabio Di Trapani, Cristoforo Demartino, Tony Fierro, to name a few but leaving out so many. See the list at the bottom of this article for a more complete appreciation list. OpenSees is really going in different, new exciting directions, as can be seen from the breath of the subjects covered in the conference. Striking new directions include metamaterial modeling and molecular dynamics. But also there is a lot going on in more classic study areas such as soil-structure interaction modeling (still no dogmas on SSI modeling I'm afraid... more research is needed) and structural mechanics. Not a lot of soil modeling going on (outside SSI) in the conference, I know there is some new stuff (geotechs should get their stuff together!). AI is entering the OpenSees stage with a lot of strength. It's cool to see all the new tools surrounding OpenSees which people are coming up with (visualizers, python interfaces, site response analysis aids, you name it!). The big star is STKO from ASDEA group, that has reached an amazing level of maturisty since last OpenSees days conference at Porto, Portugal. A lot of new research is being powered by STKO, with stunning visuals, and its good to see all the open contributions to OpenSees coming from that team. I was impressed by a few talks and I hope to hear more from the authors. Here are some in no particular order (the order of the program): Parametric investigation on damping properties of a type of snapping metamaterial . Luca Aceto, Guido Camata A finite element investigation of the size-dependent mechanical properties of graphene . Dag Pasca, Matteo Pelliciari, Angelo Aloisio, Angelo M. Tarantino Brand new symmetric and asymmetric hysteresis models in OpenSees Salvatore Sessa, Nicolò Vaiana, Francesco Marmo, Luciano Rosati. Assessment of the additional shear demand due to infills through a refined micromodel . Fabio Di Trapani, Valentina Bogatkina, Massimo Petracca, Guido Camata A disruptive strategy for structural health monitoring with STKO . Alessia Amelio, Roberto Boccagna, Maurizio Bottini, Guido Camata, Nicola Germano, Massimo Petracca, Giuseppe Quaranta On the seismic protection of existing structures: a large-scale modelling of nonlinear soil-structure-TMD interaction . Davide Noè Gorini, Guglielmo Clarizia, Pasquale Roberto Marrazzo, Rosario Montuori, Elide Nastri Enhancing seismic performance of semi-rigid connection using Shape Memory Alloy (SMA) bolts considering nonlinear soil–structure interaction . Benyamin Mohebi, Farzin Kazemi, Atefeh Yousefi Numerical evaluation of the soil-structure interaction effects on the seismic performance and vulnerability of high-rise RC buildings in southwestern Spain . Maria-Victoria Requena-Garcia-Cruz, Emilio Romero-Sanchez, Antonio Morales-Esteban Three-dimensional nonlinear soil-structure interaction modeling of a church bell tower in Guardiagrele, Italy . Onur Deniz Akan, Massimo Petracca, Guido Camata, Carlo Giovanni Lai, Enrico Spacone Modelling nonlinear static analysis for soil-structure interaction problems . Domenico Gallese, Davide Noè Gorini, Luigi Callisto Influence of boundary conditions on the site response of a basin . Tony Fierro, Maria Giovanna Durante, Massimina Castiglia, Filippo Santucci de Magistris LTruss structures in OpenSees with steel to LVL or Glubam bolted connections . Da Shi, Cristoforo Demartino, and Zhi Li A thermodynamic-based macroelement approach for dynamic analysis of soil-structure systems . Davide Noè Gorini, Luigi Callisto Authors: if you see this, get in touch! My email is my github handle followed by uandes.cl.","tags":"OpenSees","url":"https://joseabell.com/posts/2022/eosd2022-recap.html","loc":"https://joseabell.com/posts/2022/eosd2022-recap.html"},{"title":"EOSD2022 Summer School SSI Modeling","text":"Short applicative lecture given at Eurasian OpenSees Days 2022 in Turin, Italy on July 6th. Supplementary material: Slides mshopstools.py - A toy library to interface gmsh with openseespy . workshop-ssi1.geo - SSI gmsh .geo (geometry) file for the application. workshop-ssi1.msh - SSI gmsh .msh (mesh) file for the application, generated from the above file without any modifications. workshop-ssi1.py - Python script that reads the .msh file and creates and runs the OpenSees model using openseespy .","tags":"OpenSees","url":"https://joseabell.com/posts/2022/eosd2022-summer-school-ssi-modeling.html","loc":"https://joseabell.com/posts/2022/eosd2022-summer-school-ssi-modeling.html"},{"title":"Buidling a computer cluster for OpenSees","text":"As part of my recently-awarded research grant where I'll study the effects of near-field earthquakes in Santiago Chile (more on that in the future, maybe) I'm building a small cluster of computers (a beowulf cluster ). The main considerations were Maximum number of processores cores I can afford. 3 to 4 Gb of RAM per core. Setup with Ubuntu Linux (22.04) running ansible for software provisioning, SLURM, OpenMPI, and all of the OpenSees dependencies. A network shared folder for home folders and results using something fast. Connect to main node using a mixture of SSH and remote desktop software. Talking with Massimo Petarca of ASDEA, as well as based on my previous experience with running parallel OpenSees, it seems that OpenSees does not scale linearly with number of processors past 16 processes. This led me to hypothesize that we can get better performance from a distributed-memory system rather than one big server that fits all of the specs. So here is a bit of my reasoning for how I finally designed this system. Lets start with processors. Having had ample experience with Intel and knowing that they provide very fast linear algebra through the (now free to use) MLK library I initially quoted Intel-based systems. Xeons are one of the go-tos for the HPC industry. With Xeons you can get two or more sockets in the same motherboard and insane ammounts of ECC memory. This is all fine for HPC servers (which require uptime and reliability) but I don't really care for the ECC and we also won't gain much in a single motherboard because of the afore-mentioned scaling issue. What I really need is OpenSees in scalar mode (as well as in parallel with low process counts) to run fast. FastFAST! Fast Xeon processors are incredibly expensive. I side-looked into AMD territory, I've been hearing that in the desktop market AMD has been giving Intel a whopping. I was impressed and tempted with AMD Threadrippers, but I really don't need 32 cores and if I get the 16 core I might as well go cheaper with Ryzen 9's 5950X with the same core count and higher clock speeds. I also looked into the new Intel i9's which are impressive, but, though the core count is the same, i9s actually have two types of cores: performance cores (clocks over 5.0GHz) and eficiency cores (around 4.0GHz)... I really want all performance cores. Also tempting is the new DDR5 memory, but its spanking new and bound to be yet technologically unstable as motherboard manufacturers learn the tricks to tap into DDR5 territory (which is somewhat significantly different and more expensive than previous generation DDR4 memory. ). Oh... AMD can handle ECC memory BTW. Coming back to that Intel MKL, I was under the impression that it only worked on Intel computers (duh)... but its turns out you can work around this and get some break-neck performance boosts with MKL on AMDs too! (see this and this too ). So this removed the final barrier for me to opt for AMD for my cluster. So, based on all of this and my budget, for the compute nodes I'm getting 8 gaming computers outfitted with liquid cooled Ryzen 9 5950Xs (yes we will be overclocking these to get that performance boost and break into 5.0GHz territory), 64 Gb of DDR4 each, high-end Aorus motherboards, 2.5GbE network cards, and 500Gb M.2 NVMe PCIe x16 SSDs for OS and local (fast) storage options. The main (login) node will have a humbler Ryzen 9 5900X (12 cores instead of 16) and only 32 Gigs of RAM, because this is just used for login, compiling and maybe some pre/post-processing. Also it will be used for storage so its getting an extra 2Tb NVMe drive for the home folders, maybe I'll get some RAID SSDs next year. GPU you're asking? What GPU? To finish the cluster, I need a fast switch. I started out with a 48-port gigabit switch I had lying around (the one you'll see in the pictures). This is totally incapable of writing to that SSD (which can theoretically write up to 7.2 GBit/s). So I bought a couple of 8port 2.5GbE QNAP managed switches that come with two 10GbE SFP+ ports. I also added a twin-port SFP+ capable ethernet card to the main node. I'll be doing some benchmarks of all this stuff shortly to see if I get the kind of write-performance that I want on this beast. To setup the software stack, I used the BeowulfInstaller that my CS students developed last year. It installs smoothly over Ubuntu 22.04 so I'm really happy with that. We added a few extra things so I can share the large storage in the main node through NFS. I'm having lots of fun these days building, testing, benchmarking and improving this system. I'm developing and sharing all my custom benchmarks on this GitHub repo . ShakeMaker is running smoothly on the cluster and scaling linearly to all currently available 128 cores. Will be running OpenSees very soon. I want to finish with some special thanks to all that have contributed to this project over the years. Carlos Castex (permanently on the team) José Luis Assadi (team v.1) Cristobal Griffero (team v.1) Sebastián Baixas (team v.2 and v.3) Joaquin Fernandez (team v.2) José Tomás Gutiérrez (team v.2) Omar Oyarce (team v.3) Alberto Hurtado (team v.3) José Luis Larenas (team v.3) Here are some pics of us having fun configuring this thing in the civil engineering lab at UANDES. Initial setup day! Pizzas are a must! Omar (MS student), myself and Sebastián (former undergrad student, original creator of BeowulfInstaller) started working around 9PM Main node is up and running. Installing Ubuntu on a compute node. JL Larenas (future MS student) is also here for emotional support. Main node, two compute nodes and a switch. The basic setup to start testing and setting up with BeowulfInstaller The next day I added two more nodes. Some gibberish on-screen. Nice RGB lights on the RAM, I did not ask for those! Setting up more nodes and an old-fashioned rack to get everything tidy. Special visit by Rodrigo who is a EE student taking my undergrad statics class that wanted to take a look. The current setup. All my 8 nodes are up. I need to configure the QNAP switch and see what kind of performance gains I get with that. The campus electrician will help me tidy up the cables and get more power for 4 more nodes (next year we'll duplicate the ammount of nodes!) v.2 of the Cluster was using these computer labs. On the picure Joaco Fernandez and JT Gutierrez. Picture is from summer (january) 2021. Joaco, me, JT and Sebastián Baixas. The birth of BeowulfInstaller. What a team! José Luis Assadi, Cristoba Griffero, Carlos Castex and me. The original cluster team!! Photo is from March 2018.","tags":"OpenSees","url":"https://joseabell.com/posts/2022/buidling-a-computer-cluster-for-opensees.html","loc":"https://joseabell.com/posts/2022/buidling-a-computer-cluster-for-opensees.html"},{"title":"New 2021 additions to OpenSees","text":"2021 has almost gone, I haven't written on my blog almost all year, but there has been progress! I've made a bunch of small contributions this year to OpenSees (see all contributions here ) but two big ones: a new material model for high-cyclic analysis of sands (SANISAND-MS with my collaborators at TU Delft, NGI and Bristol, see here ) and added isogeometric analysis (IGA) of shells capabilities. This last contribution is very recent and is still (as of writing this) in pull request mode. I'll let some time pass, for possible review, before I definitely merge into main OpenSees. Briefly, IGA uses NURBS as a functional basis instead of regular polynomials. NURBS is a well developed CAD technology that allows very smooth modeling of lines, surfaces and volumes. Because in continuum mechanics we use lots of derivatives of the main solution field (strains, stresses come from derivatives of the displacement field) this smoothness is an advantage over regular FEM in that you can ensure inter-element continuity of these fields. This, in turn, produces some nice convergence properties. In the figure above, we can see that IGA allows for large deformation modeling. Shown is the \"pinched cylinder\" benchmark case. You can see we replicate a reference solution with accuracy. Anyway, like any new technology there are trade-offs to keep in mind. In IGA there are two nice features of FEM which are lost: first, the concept of element and, second, the interpolatory property for nodal values. In the first issue, the higher continuity attained by the NURBS basis is obtained by \"overlaping\" elements for continuity order 2 and above. Thus, in IGA one is more preoccupied with \"patches\" of elements, which for all intents and purposes can be thought of as a regular finite element with a variable (large) number of nodes which is mapped onto a rectangular parent domain. Regarding the second issue, lets use a picture Shown is a standard cantilever beam modeled as a single \"patch\" of IGA \"elements\", with a tip load and solved using the new OpenSees capabilities (see script here ). Depending on the order of continuity you can have 2 elements (order 2) or 1 element (order 3) in the longitudinal direction, whereas order is 1 in the transverse direction. You can see the control points (terminology for nodes in IGA) do not belong to the surface, except at the edges of the patch. Depending on specific details, not even the patch edges are generally included in the surface. The DOFs at the control points are the displacements of the control points, which uniquely describe the shape of the surface. The other thing to note is that two rows of control points are fixed. This is to enforce the no-rotation (clamped) boundary condition at the left edge. The shell formulation used is a Kirchoff-Love formulation which only has displacements at the control points as DOFS (no rotations). This can take a bit getting used to if you do classical shell analysis where elements have 6 DOFS (3 displacements and 3 rotations) at each node. Oh, by the way, that is not an amplified deformed shape, e.g. those are real displacements... Another annoying thing about IGA is that if you want to do anything more complex (or you want a better mesh) you'll need several patches. If the edge nodes are interpolatory (as is assumed in the OpenSees implementation for shells), then only C0 continuity is available across patches, which means you have to do some tricks to guarantee bending stiffness across patch boundaries. More on this in a future video I hope. For now, I'll wrap up with more pics of large deformation, highly-nonlinear, snappy-throughy analysis cases whet your appetite for IGA. All can be found in the examples repo ( here ) if you're patient.","tags":"OpenSees","url":"https://joseabell.com/new-2021-additions-to-opensees-EN.html","loc":"https://joseabell.com/new-2021-additions-to-opensees-EN.html"},{"title":"Temas de Magister/Memoria 2022","text":"Al final de la licenciatura (terminando \"Métodos Computacionales en Obras Civiles\") el alumno UANDES de la especialidad de Obras Civiles debe considerar si se va por la mención de \"Estructuras\" o por la de \"Diseño de Proyecto de Infraestructuras\". Además, si extenderá su carrera con un magister de continuidad o cerrará con un proyecto de título (memorias en la jerga antigua). Esta es mi oferta de temas de magister o proyecto de título: Magister Se busca alumno de Magister para el siguiente tema: \"Modelación de alta-fidelidad para análisis de estructuras sometidas a sismos de campo cercano \" La idea es modelar en detalle el proceso completo de un evento sísmic: desde la ruptura (la falla sísmica), pasando por la propagación de ondas por la corteza terrestre, incluyendo posiblemente efectos no-lineales de respuesta de sitio, y finalmente las estructuras. Usaremos computación de alto desempeño en todas las etapas, es decir, el problema es tan grande y complejo que requiere el uso de más de un computador para resolverlo! Se modelará en OpenSees usando la herramienta STKO . Se usará harto python o incluso C++ si le interesa al estudiante. Para más detalles y/o ayuda a discernir esta etapa, no dudes en contactarme directamente para conversar y aclarar dudas. Proyectos de título Se ofrecen los siguientes temas: TEMA02: Modelación y simulación de colapso de represas por desbordamiento. En un estudio anterior (Magister Nicolás Galano), se desarrolló una extensión al programa de elementos finitos OpenSees que permite simular explícitamente el proceso de socavación. Ahora, se busca aplicar este programa en la simulación del colapso de represas por desbordamiento. TEMA03: Análisis de agrietamiento térmico de hormigones masivos Este tema mezcla adquisición de datos experimentales usando sensores y placas Raspberri Pi y simulación numérica para estudiar el tema de agrietamiento térmico en hormigones. Se continúa el trabajo de Álvaro Contreras y José Tomás Arteaga, extendiendolo al problema de predicción de agrietamiento. TEMA04: Desarrollo y simulación de un sistema avanzado de fundaciones para edificios En este trabajo se trabajará en conjunto con la empresa geotécnica R&V en el desarrollo de un diseño innovador de fundaciones profundas optimizadas para edificioes en Chile. TEMA05: Benchmarking del clúster de supercómputo de la facultad de ingeniería Este tema está orientado a alumnos de ingeniería de computación (aunque también para un ingeniero eléctrico que sea buen programador) con ganas de trabajar más a bajo nivel. Durante el 2020 y el verano del 2021 se reconfiguró a sala de computación de ingeniería (100 computadores) para trabajar como un clúster de supercómputo. Esto significa que se puede coordinar la ejecución de tareas utilizando los recursos de los 100 computadores de manera simultánea (600 cores, 1.6Tb de memoria RAM distribuída, 10Tb de almacenamiento) para resolver problemas de mayor envergadura (por complejidad computacional y/o cantidad). La idea es desarrollar una serie de benchmarkas (problemas tipo) a resolver que permita entender el desempeño de este sistema en términos de su capacidad computacional e identificar el tipo de problemas para el que resulte más eficiente.","tags":"Teaching","url":"https://joseabell.com/temas-de-magistermemoria-2022-ES.html","loc":"https://joseabell.com/temas-de-magistermemoria-2022-ES.html"},{"title":"Temas de Magister/Memoria 2021","text":"Al final de la licenciatura el alumno UANDES debe comenzar a considerar si extenderá su carrera con un magister de continuidad o cerrará con un proyecto de título. En cualquier caso se deben considerar posibles temas a estudiar en esta etapa. Esta es mi oferta de temas de magister o proyecto de título. Para más detalles y/o ayuda a discernir esta etapa, no dudes en contactarme directamente para conversar y aclarar dudas. Magister Se busca alumno de Magister para el siguiente tema: \"Modelación de alta-fidelidad para análisis de ciclo de vida de puentes chilenos\" En esta investigación se utilizarán herramientas de simulación estructural avanzadas para construir modelos no-lineales dinámicos de un puente chileno. Este modelo incorporará la capacidad de predecir daño en elementos estructurales de hormigón armado para distintos niveles de degradación por corrosión. Además se modelarará en detalle la interacción suelo-estructura en cepas y pilotes de fundación, incorporando una modelación simplificada de la posibilidad de socavación por crecidas de río. Finalmente, se someterá el modelo a simulaciones transientes para determinar la capacidad de Hay financiamiento FONDECYT para pagar matrícula o estipendio . Se busca un alumno con aptitudes para programar, capaz de usar Linux (o muchas ganas de aprender) y un interés por la simulación avanzada en ingeniería estructural y el uso de computación de alto desempeño. Memorias Se ofrecen los siguientes temas: TEMA01: Desarrollo de un amortiguador friccional en base a impresión 3-D. Este tema mezcla modelación e impresión 3-D con simulación numérica para realizar el diseño de un dispositivo de disipación de energía friccional. Se continúa el trabajo de Joaquín Andreani en el tema. TEMA02: Modelación y simulación de colapso de represas por desbordamiento. En un estudio anterior (Magister Nicolás Galano), se desarrolló una extensión al programa de elementos finitos OpenSees que permite simular explícitamente el proceso de socavación. Ahora, se busca aplicar este programa en la simulación del colapso de represas por desbordamiento. TEMA03: Análisis de agrietamiento térmico de hormigones masivos Este tema mezcla adquisición de datos experimentales usando sensores y placas Raspberri Pi y simulación numérica para estudiar el tema de agrietamiento térmico en hormigones. Se continúa el trabajo de Álvaro Contreras y José Tomás Arteaga, extendiendolo al problema de predicción de agrietamiento. TEMA04: Desarrollo y simulación de un sistema avanzado de fundaciones para edificios En este trabajo se trabajará en conjunto con la empresa geotécnica R&V en el desarrollo de un diseño innovador de fundaciones profundas optimizadas para edificioes en Chile. TEMA05: Benchmarking del clúster de supercómputo de la facultad de ingeniería Este tema está orientado a alumnos de ingeniería de computación (aunque también para un ingeniero eléctrico que sea buen programador) con ganas de trabajar más a bajo nivel. Durante el 2020 y el verano del 2021 se reconfiguró a sala de computación de ingeniería (100 computadores) para trabajar como un clúster de supercómputo. Esto significa que se puede coordinar la ejecución de tareas utilizando los recursos de los 100 computadores de manera simultánea (600 cores, 1.6Tb de memoria RAM distribuída, 10Tb de almacenamiento) para resolver problemas de mayor envergadura (por complejidad computacional y/o cantidad). La idea es desarrollar una serie de benchmarkas (problemas tipo) a resolver que permita entender el desempeño de este sistema en términos de su capacidad computacional e identificar el tipo de problemas para el que resulte más eficiente.","tags":"Teaching","url":"https://joseabell.com/temas-de-magistermemoria-2021-ES.html","loc":"https://joseabell.com/temas-de-magistermemoria-2021-ES.html"},{"title":"Compiling OpenSees 3.2.0 on Ubuntu 20.10: a tutorial and commentary","text":"In this short video I teach you how to compile OpenSees 3.2.0 on Ubuntu Linux 20.10. Compilation is setup with no \"bells and whistles\", meaning its not optimized in any way and does not include any extra features. The history file mentioned in the video can be found here and this is the Makefile.def . Check out Silvia's Brainery and Michael Scott's blog for more awesome OpenSees stuff!","tags":"OpenSees","url":"https://joseabell.com/compiling-opensees-320-on-ubuntu-2010-a-tutorial-and-commentary-EN.html","loc":"https://joseabell.com/compiling-opensees-320-on-ubuntu-2010-a-tutorial-and-commentary-EN.html"},{"title":"STKO OpenSees review","text":"A created a short #review of STKO: a pre/post processor for #OpenSees which I think is really cool and brings fresh new stuff into OpenSees to benefit all. https://t.co/EnMAVAnRya — José Antonio Abell (@RealJoseAbell) November 30, 2020","tags":"OpenSees","url":"https://joseabell.com/stko-opensees-review-EN.html","loc":"https://joseabell.com/stko-opensees-review-EN.html"},{"title":"Nicolás Galano defends his MS Thesis","text":"Congratulations Nico! Remember this tweet? I'm proud to announce the MS defense of my (co)-MS student Nicolás Galano, who worked on extending #PFEM on #OpenSees for scour modeling. We stand on the shoulder of giants. Original #PFEM implementation by @mikusscott and @MinjieZhuOS . Thanks guys! https://t.co/K6rfp8FjPj pic.twitter.com/AiwGGnSFQH — José Antonio Abell (@RealJoseAbell) September 9, 2020 Great results! pic.twitter.com/L6NikXiqh3 — José Antonio Abell (@RealJoseAbell) September 9, 2020","tags":"GroupNews","url":"https://joseabell.com/nicolás-galano-defends-his-ms-thesis-EN.html","loc":"https://joseabell.com/nicolás-galano-defends-his-ms-thesis-EN.html"},{"title":"Paper04 - Modelling the cyclic ratcheting of sands through memory-enhanced bounding surface plasticity.","text":"Abstract The modelling and simulation of cyclic sand ratcheting is tackled via a plasticity model formulated withinthe well-known critical state, bounding surface SANISAND framework. For this purpose, a third locus –termed ‘memory surface' – is cast into the constitutive formulation, so as to phenomenologically capturemicro-mechanical, fabric-related processes directly relevant to the cyclic response. The predictive capabilityof the model under numerous loading cycles (‘high-cyclic' loading) is explored with focus on drainedloading conditions, and validated against experimental test results from the literature – including triaxial,simple shear and oedometer cyclic loading. The model proves capable of reproducing the transition fromratcheting to shakedown response, in combination with a single set of soil parameters for different initial,boundary and loading conditions. This work contributes to the analysis of soil-structure interaction underhigh-cyclic loading events, such as those induced by environmental and/or traffic loads. This is the first paper fruit of the on-going collaboration with Federico Pisanò at TU Delft. Here we tackle the problem of formulating a constitutive model, derived from the SAniSand framework by Yannis Dafalias, which can replicate the ratcheting phenomenon on sands. What is ratcheting? This is a ratchet! Ratchetin' is what it do. This is a ratchet. It ratchets. In all seriousness, when soils are subjected to asymmetrical loading, for example because there may be a static shear load acting on it and then it gets shaken, the soil accumulates irrecoverable strain as it cycles. Typical constitutive models predict a constant rate of strain accumulation for this type of loading, and that is what needs to be fixed. Only drained ratcheting response is pursued here, the undrained behavior is get its own (already accepted) article (see this for more info on this publishing strategy. (joke Fede) ). So, Federico and his great PhD student Haoyuan Liu together with Andrea Diambra at Bristol University integrated the idea of memory surface (which was applied to granular soils by Corti and Diambra in 2016 ) to extend the SAniSand constitutive and fix this. We affectionately baptized this model RatchySand ... a play on the SAniSand origins of the model and ratchyness. Officially we call the model SAniSand-MS , in line with other models that have been developed in the same family. The concept of memory surface (MS) is a way to keep track of stress states that the soil has visited previously, a type of soil fabric effect. When the soil re-visits this area then it should remember and respond with higher stiffness. Its explained in greater depth in the article, go read it to get the best experience . The main point is that SAniSand's fabric tensor gets replaced with a new formulation based on the MS. The memory surface remains within the yield surface which remains within the bounding surface throughout material response. The more surfaces the better. The model adds a few extra parameters to the original formulation, these parameters control the way the memory surface hardens and expands or contracts, all while ensuring that the yield surface stays within the MS. Calibration of the new model parameters requires cyclic asymmetric DSS or Drained Triaxial data... for a lot of cycles... many. (Calibration data comes from Wichtman et. al. 2005 ). In this \\(q-\\epsilon_a\\) plot the constitutive response is shown to reach a limiting value for increasing number of cycles. Response You might be askin: but what did you do José . My humble contribution was to implement this constitutive model for general states of stress in OpenSees . For some time I've been in the developer team for OpenSees... which means my portrait appears on the OpenSees Project github page (which is nice). Anyway, the process of implementing and testing the model on OpenSees gave some nice insights into the model and allowed testing in some uncharted territory of the deviatoric plane. The idea, obviously, is to follow-up with some FEM applications using the power of this new tool. We already have some things to show for this, which are coming up. Just would like to close thanking my collaborators: Federico, Andrea and most especially he who did the hard work Haoyuan. Y'all rock.","tags":"Publications","url":"https://joseabell.com/posts/2020/paper04-modelling-the-cyclic-ratcheting-of-sands-through-memory-enhanced-bounding-surface-plasticity.html","loc":"https://joseabell.com/posts/2020/paper04-modelling-the-cyclic-ratcheting-of-sands-through-memory-enhanced-bounding-surface-plasticity.html"},{"title":"Large earthquake in Mexico triggers tsunami warnings","text":"The magnitude I gave came from the Tsunami threat record. pic.twitter.com/2h5dppVLLQ — José A. Abell 🇻🇦🇨🇱 (@jose_abell) June 23, 2020","tags":"Earthquakes","url":"https://joseabell.com/large-earthquake-in-mexico-triggers-tsunami-warnings-EN.html","loc":"https://joseabell.com/large-earthquake-in-mexico-triggers-tsunami-warnings-EN.html"},{"title":"#EngineeringWizardry | 00 | new series","text":"Stuck teaching during COVID-19 lockdowns in Chile has reminded me one crucial thing about statics (the class I'm teaching this first semester in the southern hemisphere): it can be very frustrating for students . This frustriation comes from unmet expectations. They're just finishing their early maths and physics formation (Calculus, Linear Algebra, Differential Equations, physics etc. ), an ideal world where problems have nice answers such as \\(\\sqrt{2} \\pi\\) or no answer at all. Then, along comes statics, and the world seems upside down. Not only are the contents of statics deceptively simple ( \\(\\sum F=0\\) pretty much sums it up... get it?... sums?... ok), the only way through is through exercising... a lot. This cannot be over-emphasized. The biggest hurdle through this is, ironically, maths. Yes! The very thing they've been becoming experts at. Take this example: The problem comes in two flavors depending what you ask for: Given how much you want the vertex node to move (that is, give values to \\(u_x\\) and \\(u_y\\) ), find the forces \\(F_x\\) and \\(F_y\\) that need to be applied. Given the forces \\(F_x\\) and \\(F_y\\) find out the displacement of the vertex node ( \\(u_x\\) and \\(u_y\\) ). One of this forms is easier thant the other. Which one? Think about it... take your time. Click to know the answer... NUMBER 2 Why? Glad you asked! In #2 you fix the geometry of the problem. Finding the change in length of the springs is trivial.From that you can find the forces carried by each spring and from that the force applied comes from stating a simple particle force equilibrium at the vertex. Form #1 fixes the applied forces. This means that the geometry is unknown, which leads to a nonlinear system of equations that needs to be solved so that the displacements \\(u_x\\) and \\(u_y\\) result in spring stretches such that the equilibrium is satisfied. The form of the problem notwidthstanding, to me as a teacher what's important about this problem is: Stating the single-particle equilibrium where the springs meet. Drawing a free body diagram. This is the same for both forms. Expressing the forces of the springs as a function of the stretch. Expressing the direction of the forces as a function of the point displacements. Writing down equilibrium Getting an answer and check whether it makes sense . Part 1 can be done, with experience, in under 5 minutes. Part 2, on the other hand, can take about 10 to 15 minutes if form 1 is used. If form 2 is used all bets are off, the students can't be expected to solve those equations in a quiz/midterm/exam setting. (This is another subtle issue, that easy-to-state problems can easily derail into a mathematical nightmare if one is not careful). The main problem, then, is that students spend a lot of time doing maths instead of statics. Since answers are important, to check whether the results make sense, gain experience and because otherwise nothing would make sense; the effort of solving problems must be addressed. If the way to study statics is solving as many problems as one can, but the math/geometry is what takes up all the time and is least important to becoming a good engineering modeler, how to avoid this? Programming is a way to go. But, as much as I regret it, that does not come easy to all students at this point of their formation: would result in two problems instead of one. But there is hope: behold geogebra ! It's a powerful and intuitive set of apps for the PC, cellphone, through the browser, etc. I'm planning on using this to bridge the math gap and accelerate student learning. After this long roundabout, I can finally state that this is my motivation behind the #EngineeringWizardry youtube series I intent to develop in the next months. I hope it helps you and my students.","tags":"EngineeringWizardry","url":"https://joseabell.com/posts/2020/engineeringwizardry-00-new-series.html","loc":"https://joseabell.com/posts/2020/engineeringwizardry-00-new-series.html"},{"title":"Using my gmshtranslator python tool to interface gmsh with opensees.","text":"I wrote the gmshtranslator tool a while back during my PhD, to easily parse gmsh msh files to any other format. I've been using it for years now with not much change for both research and consulting, and have been contacted by other researchers that want to use it. I will soon write a tool, powered by gmshtranslator , to more easily translate from gmsh into OpenSees. Meanwhile, here is a short example on how to use gmshtranslator to create OpenSees models. The example assumes you know gmsh formats ( .geo and .msh ) and python. The example consists on the simple cantilever beam shown in the following figure. The beam is fixed at the right end, and has node-by-node forcing on the right end. The following gmsh .geo. script prepares the domain. beam.geo : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 LX = 5 ; LY = 0.5 ; Nx = 40 ; Ny = 5 ; Point ( 1 ) = { 0 , 0 , 0 , 1 }; Point ( 2 ) = { LX , 0 , 0 , 1 }; Point ( 3 ) = { LX , LY , 0 , 1 }; Point ( 4 ) = { 0 , LY , 0 , 1 }; Line ( 1 ) = { 1 , 2 }; Line ( 2 ) = { 2 , 3 }; Line ( 3 ) = { 3 , 4 }; Line ( 4 ) = { 4 , 1 }; Line Loop ( 1 ) = { 1 , 2 , 3 , 4 }; Plane Surface ( 1 ) = { 1 }; Transfinite Line { 1 , 3 } = Nx + 1 ; Transfinite Line { 2 , 4 } = Ny + 1 ; Transfinite Surface { 1 }; Recombine Surface { 1 }; Physical Line ( \"Fixed\" ) = { 4 }; Physical Line ( \"Forcing\" ) = { 2 }; Physical Surface ( \"Beam\" ) = { 1 }; Mesh ( 2 ); 3 physical groups are defined: fixed to identify the fixed nodes, forcing to identify the nodes that will carry loads, and beam contains all the quad elements to represent the body of the beam. Note the optional use of the transfinite meshing algorithm. Once this script is executed in gmsh the .msh file can be exported. The resulting .msh file can be found here . gmshtranslator parses the .msh file, executing code depending on certain user-defined rules. What we want to do is define an opensees node command for each node in the .msh file, fix the nodes contained in the fixed physical group, generate forces for the nodes in the forcing physical group, and add quad elements for each quad in the .msh file. First, import the beam.msh file into gmshtranslator and open files to be written that will contain the opensees code. 1 2 3 4 5 6 7 8 9 10 from gmshtranslator import gmshTranslator mshfname = \"beam.msh\" gt = gmshTranslator ( mshfname ) fid_nodes = open ( mshfname . replace ( \".msh\" , \".nodes.tcl\" ), \"w\" ) fid_elements = open ( mshfname . replace ( \".msh\" , \".elements.tcl\" ), \"w\" ) fid_fixities = open ( mshfname . replace ( \".msh\" , \".fixities.tcl\" ), \"w\" ) fid_loads = open ( mshfname . replace ( \".msh\" , \".loads.tcl\" ), \"w\" ) I like writing different things (nodes, elements, etc.) in separate files for debugging. Your style might be different. gmshtranslator parses the file and evaluates rules . A rule is composed of a condition that must be met and an action to be executed, these are both python functions. There are rules for nodes and for elements. The syntax for node and element conditions are: 1 2 def node_condition ( tag , x , y , z , physgroups ): def element_condition ( eletag , eletype , physgrp , nodes ): These are functions that evaluate to true or false depending on the inputs. Then the syntax for actions are: 1 2 def node_action ( tag , x , y , z ): def element_action ( eletag , eletype , physgrp , nodes ): These functions don't return anything, instead excecute whatever code should be executed if the condition of the rule is met. Rules are added to the parser by using the add_nodes_rule or add_elements_rule function of gmshtranslator and are excecuted whenever the parse() method is called. For example, the rule to add all nodes to the opensees domain would be: 1 2 3 4 5 6 7 def is_node ( tag , x , y , z , physgroups ): return True def add_node ( tag , x , y , z ): fid_nodes . write ( \"node {} {} {} \\n \" . format ( tag , x , y )) gt . add_nodes_rule ( is_node , add_node ) The node condition ( is_node ) function always returns true , that is this rule will execute for all nodes. The action function is add_node and will write the appropriate text into the nodes file. The rule is added into the parser by using the gt.add_nodes_rule function which accepts two python functions as arguments: a condition and an action. The code for the rest of the example is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def fix_node ( tag , x , y , z ): fid_fixities . write ( \"fix {} 1 1 \\n \" . format ( tag )) def add_load ( eletag , eletype , physgrp , nodes ): fid_loads . write ( \"load {} $fx $fy \\n \" . format ( nodes [ 0 ])) fid_loads . write ( \"load {} $fx $fy \\n \" . format ( nodes [ 1 ])) def add_element ( eletag , eletype , physgrp , nodes ): fid_elements . write ( \"element quad {} {} {} {} {} $thick PlaneStress $mat_tag \\n \" . format ( eletag , nodes [ 0 ], nodes [ 1 ], nodes [ 2 ], nodes [ 3 ])) gt . add_nodes_rule ( gt . is_node_in ( \"Fixed\" ), fix_node ) gt . add_elements_rule ( gt . is_element_in ( \"Forcing\" ), add_load ) gt . add_elements_rule ( gt . is_element_in ( \"Beam\" ), add_element ) Note that we didn't write a condition for the fix_node action, instead we used some of the simple conditions contained in gmshtranslator that can simplify some typical situations. In this case the gt.is_node_in() function takes a physical group name and evaluates whether each node is in that physical group. An equivalent python code for this would be: 1 2 3 Fixed = 1 # Physical group number assigned by gmsh to the 'Fixed' group def is_node_in_Fixed ( tag , x , y , z , physgroups ): return Fixed in physgroups Or using gmstranslator s internal mapping. 1 2 def is_node_in_Fixed ( tag , x , y , z , physgroups ): return gt . physical_groups_by_name [ 'Fixed' ] in physgroups \\ The same holds true for the add_load and add_element rules, I just opted to use the simple function but could have written a condition function from scratch. Add all rules to the parser by callig the add_X_rule functions. Finally, call parse to execute and generate all output files. 1 gt . parse () Don't forget to close files people! 1 2 3 4 fid_nodes . close () fid_elements . close () fid_fixities . close () fid_loads . close () Run the python script and, voillá! Meshing done. Finally, for completeness, here is the OpenSees tcl code that runs the complete example. I used elastic-isotropic material and a simple static analysis. I added only vertical loading on the tip of the beam. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 model BasicBuilder - ndm 2 - ndf 2 set thick 1.0 set mat_tag 1 set E 200 .e9 set nu 0.3 nDMaterial ElasticIsotropic $mat_tag $E $nu source \"beam.nodes.tcl\" source \"beam.fixities.tcl\" source \"beam.elements.tcl\" set tstag 1 timeSeries Linear $tstag 1.0 set Ly 0.5 set Ny 5 set dy [expr $Ly / $Ny ] set fx [expr 0 * $dy / 2 ] set fy [expr - 10 . * $dy / 2 ] pattern Plain 1 \"Linear\" { source \"beam.loads.tcl\" } recorder pvd disp disp constraints Plain numberer RCM system UmfPack test NormDispIncr 1.0 e-9 10 algorithm Newton integrator LoadControl 1 analysis Static analyze 1 The pvd recorder is used to generate a nice output file that can be viewed using paraview .","tags":"Tutorials","url":"https://joseabell.com/posts/2018/using-my-gmshtranslator-python-tool-to-interface-gmsh-with-opensees.html","loc":"https://joseabell.com/posts/2018/using-my-gmshtranslator-python-tool-to-interface-gmsh-with-opensees.html"},{"title":"Paper03 - Earthquake Soil Structure Interaction of Nuclear Power Plants, differences in response to 3-D, 3 × 1-D, and 1-D excitations","text":"Summary: Finally! First paper since PhD was accepted for publication. I'll take this opportunity to start a tradition and review my own papers here. I think its important that I do this for several reasons. First, there are discussions that come up during peer review that are important but don't make it into the paper. Misconceptions about the presented work can be clarified to a broader audience here. Also, I can say whatever I want, specially opinions and thoughts that come from intuition and might not make it through peer-review, I'll be as critical as possible about these too and hope that my readers can discuss with me. I can post videos... Finally! First paper since PhD was accepted for publication. I'll take this opportunity to start a tradition and review my own papers here. I think its important that I do this for several reasons. First, there are discussions that come up during peer review that are important but don't make it into the paper. Misconceptions about the presented work can be clarified to a broader audience here. Also, I can say whatever I want, specially opinions and thoughts that come from intuition and might not make it through peer-review, I'll be as critical as possible about these too and hope that my readers can discuss with me. I can post videos and other additional content here and make them available to everyone for free. And, finally, this post will have a Disqus thread Lets get to it! Here is the citation so far (I still don't have an issue assign, going through editorial process): Abell Mena J A , Orbović N, McCallen D B, Jeremic B. Earthquake soil-structure interaction of nuclear power plants, differences in response to 3-D, 3×1-D, and 1-D excitations. Earthquake Engng Struct Dyn. 2018;1–18. [https://doi.org/10.1002/eqe.3026]. The idea is simple: to show that the 3-D character of seismic motions has an impact on the structural response of a nuclear power-plant by comparing the response to 3-D motions with the one produced by an equivalent 1-D (1 component: horizontal) or 3×1-D (3 components) motion. Here is the NPP model used in the article: And its fixed-base eigenmodes: I was required by the peer-reviewers to include these fixed-base modes in the article. These are interesting, but they're not too relevant to the SSI system. SSI significantly changes the participation of the modes. I've found it useful to stop thinking in terms of eigen modes for these kind of problems, it is better to think in terms of the requirements of wave-propagation. In the paper, I use the domain reduction method (DRM) to couple a 3-D seismic simulation of the wave propagation from source to site with a local site and structure model. This domain split allows the fully 3-D modeling of the motions into the structure, accurately. Also, importantly, it allows the separation of the seismic and NPP simulation, using separate dedicated programs for each task as opposed to one big complex simulation. This reduces the computational cost dramatically and allows more modeling freedom. From the free-field response of the site (e.g. with no NPP on top) equivalent 1-D and 3×1-D motions were developed using 1-D site deconvolutions in Shake and input into the model for comparison. Here's a plot of what the differences look like for the top of the containment building. 1-D or 3×1-D waves deliver energy in-phase to the foundation of the structure, resulting in enhanced response when compared to a full 3-D response. In this particular case, it would be conservative (looking at response accelerations and displacements) to use 1-D modeling of the seismic input. But, here is a point that couldn't be made in the article, this depends on the system and I have found cases where the results are opposite: it is nonconservative to ignore 3-D ground motions effects. This point needs to be made more clearly (future work), for different seismic settings and structures. I also ran this model using a non-linear constitutive model for the soil. Check out what the energy dissipation looks like under the NPP (not part of the paper). This was submitted for review Jan 6 2017, it took over a year to get acceptance! Three iterations of peer-review were done. Admittedly, I did take too much time to answer. Tough year was 2017. Although the reviewers were very picky, which led to article improvement--especially the introduction--, the main content of the article changed little. We have the same results and conclusions. Where from here? It think DRM-based SSI analysis is the methodology to produce the highest-possible fidelity modeling of SSI. But generating these DRM motions is costly, we need supercomputers for that. Highly-detailed modeling of seismic motions is currently underway, it would be rather cheap for the researchers doing these simulations to also generate DRM-compatible motions for future exploration, making these simulations even more relevant. There needs to be an agreed format for the distribution of DRM motions, and a repository of validated motions to be used for modeling. Is it worthwhile? That's a research question in of itself. Clearly we can build to withstand earthquakes, so its not a safety-critical issue to use advanced SSI modeling. Might be an economic one. Maybe some case-studies can be reinterpreted in the light of 3-D motions to suggest that they were to blame in unexpected performance of existing infrastructure. Some structures will be more sensitive to these effects than others, which? how much so? under what conditions? is it necessary to model them in this way? There is great value in high-fidelity SSI modeling, is there a way to bring this into practice? All questions I want to answer in the years to come.","tags":"Publications","url":"https://joseabell.com/posts/2018/paper03-earthquake-soil-structure-interaction-of-nuclear-power-plants-differences-in-response-to-3-d-3-1-d-and-1-d-excitations.html","loc":"https://joseabell.com/posts/2018/paper03-earthquake-soil-structure-interaction-of-nuclear-power-plants-differences-in-response-to-3-d-3-1-d-and-1-d-excitations.html"},{"title":"Video of 2-D SSI model of an RC Shear Wall Building","text":"The RC shear-wall building is modeled in OpenSees using non-linear fiber based beam column elements. Soil is modeled as a continuum using quad elements and linear stress-strain relationship. Soil shear wave-speed is varied in depth such as to obtain a \\(V_{s30}\\) consistent with a class B site according to chilean seismic code. Lysmer-Kulhemeyer dashpots are used along the soil boundary to model seismic radiation and earthquake wave-field input. The performance of the building will be assessed for varying site fundamental periods. This is an aspect of SSI that is not covered by the chilean seismic code, and has been shown to be a problem in past earthquakes. This is part of an on-going study with Prof. Carolina Magna from Adolfo Ibañez Unversity and her MS student Miguel Ángel Rodriguez from UDP.","tags":"ResearchHighlight","url":"https://joseabell.com/posts/2017/video-of-2-d-ssi-model-of-an-rc-shear-wall-building.html","loc":"https://joseabell.com/posts/2017/video-of-2-d-ssi-model-of-an-rc-shear-wall-building.html"},{"title":"New cable element in OpenSees","text":"With my student, Pablo Ibañez, we implemented a new catenary cable element in OpenSees. This element is based on the work by Salehi et al[1]. The stiffness of this element is obtained using a flexibility formulation. Basically the shape of the cable is determined by the integral: $$ \\newcommand{\\pare}[1]{\\left( #1 \\right)} \\newcommand{\\brak}[1]{\\left[ #1 \\right]} \\newcommand{\\brac}[1]{\\left\\lbrace #1 \\right\\rbrace} \\newcommand{\\vect}[1]{\\boldsymbol{#1}} \\newcommand{\\uv}[1]{\\hat{\\boldsymbol{#1}}} \\newcommand{\\ud}{\\,\\mathrm{d}} \\begin{align*} \\vect{x}(s) = \\vect{x}_1 - \\int_0&#94;s \\dfrac{\\vect{w}s + \\vect{f}}{\\Vert \\vect{w}s + \\vect{f} \\Vert&#94;2}\\pare{\\dfrac{\\Vert \\vect{w}s + \\vect{f} \\Vert}{EA} + \\pare{1 + \\alpha \\Delta T}} \\ud s \\\\ \\vect{w} = \\brak{w_1,\\, w_2,\\, w_3}&#94;T \\qquad \\vect{f} = \\brak{f_1,\\, f_2,\\, f_3}&#94;T \\end{align*} $$ Where \\(\\vect{x_1}\\) is the position of the first node of the cable, \\(\\vect{w}\\) is the weight vector in each direction, \\(EA\\) is the stiffness, \\(\\alpha \\Delta T\\) is the change in strain due to temperature and \\(\\vect{f}\\) is the force vector at the start node. This equation is iterated (with the forces as variable) upon until the the shape of the cable matches the nodal postiions imposed by the finite element program (trial displacements). Then it is used to derive a stiffness matrix. The element, as is, passes all our static verification tests. With the additional assumption of a lumped-mass matrix, we're currently working on a dynamic verification suite as well as some validation experiments. The animation above was created using OpenSees to simulate the cable and Blender to render it. Reference [1] Salehi Ahmad Abad, M., Shooshtari, A., Esmaeili, V., & Naghavi Riabi, A. (2013). Nonlinear analysis of cable structures under general loadings. Finite Elements in Analysis and Design, 73, 11–19. https://doi.org/10.1016/j.finel.2013.05.002","tags":"ResearchHighlight","url":"https://joseabell.com/posts/2017/new-cable-element-in-opensees.html","loc":"https://joseabell.com/posts/2017/new-cable-element-in-opensees.html"},{"title":"OpenSees coming to python!","text":"One of the gripes a lot of people have with OpenSees is that it adopts TCL as its interpreter language. Originally, OpenSees was conceived as a framework , this is apparent from the main page of the wiki : OpenSees, the Open System for Earthquake Engineering Simulation, is an object-oriented, open source software framework. It allows users to create both serial and parallel finite element computer applications for simulating... So, it was meant to be a neat way to build new FEM software. For years the only actual (known) application to use the OpenSees framework was what came to be known as OpenSees proper, a TCL interpreter extended with OpenSees modeling commands. Talking with Frank McKenna, the mind behind OpenSees, this stemmed from then need to show an actual application which could demonstrate the idea of the OpenSees framework in a quick and dirty way. The vision was that people would get the OpenSees source and build new and exciting finite-element software. It was \"up to the skills of the user\", like the main wiki page still reads. Sadly, civil engineers are not very code-savvy and no (useful) new applications came. Therefore it came to pass that the OpenSees extension of the TCL interpreter became OpenSees and this is what everyone uses. Now TCL is an awkward language for a scientific application, mainly due to syntax and lack of a complete library for scientific computing. Python, on the other hand, has proven in the recent years to be a worthy replacement of the mighty Matlab. Many of us started scientific computing in Matlab and then migrated to the free world of Python. It was just logical that OpenSees would benefit much more from using Python as its language of choice rather than TCL. It has finally happened, and this blog post celebrates my joy. Behold the following analysis case written in Python. import opensees as ops ops . wipe () ops . model ( 'basic' , '-ndm' , 3 , '-ndf' , 3 ) for e in range ( 3 ): ops . node ( 1 + 4 * e , 0. , 0. , 1. * e ) ops . node ( 2 + 4 * e , 1. , 0. , 1. * e ) ops . node ( 3 + 4 * e , 1. , 1. , 1. * e ) ops . node ( 4 + 4 * e , 0. , 1. , 1. * e ) ops . fix ( 1 , 1 , 1 , 1 ) ops . fix ( 2 , 1 , 1 , 1 ) ops . fix ( 3 , 1 , 1 , 1 ) ops . fix ( 4 , 1 , 1 , 1 ) ops . nDMaterial ( \"ElasticIsotropic3D\" , 1 , 2100. , 0.3 , 0.0 ) ops . element ( \"stdBrick\" , 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ) ops . element ( \"stdBrick\" , 2 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 1 ) ops . timeSeries ( \"Linear\" , 1 ) ops . pattern ( \"Plain\" , 1 , 1 , \"-fact\" , 1.0 ) ops . load ( 1 + 4 * e , 0. , 0. , - 50. ) # Load at the first of the top nodes. ops . system ( \"BandSPD\" ) ops . numberer ( \"RCM\" ) ops . constraints ( \"Plain\" ) ops . algorithm ( \"Linear\" ) ops . integrator ( \"LoadControl\" , 1.0 ) ops . analysis ( \"Static\" ) ops . analyze ( 1 ) This example just stacks two bricks and applies a downward load on one of the top nodes. The interesting part is that now you can interact with all of the rich tools available in python. Just as a taste of what's to come, here is a plot of the deformed shape of the example above created using matplotlib's 3-D plotting capabilities. And here's the code that achieves this: ### Plot bricks in the domain import scipy as sp import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt . figure () ax = fig . add_subplot ( 111 , projection = '3d' ) for e in ops . getEleTags (): nodes = ops . eleNodes ( e ) Nnodes = len ( nodes ) xyz = sp . zeros (( Nnodes , 3 ), dtype = sp . double ) uu = sp . zeros (( Nnodes , 3 ), dtype = sp . double ) for i in range ( Nnodes ): xyz [ i ,:] = ops . nodeCoord ( nodes [ i ]) uu [ i ,:] = ops . nodeDisp ( nodes [ i ]) print x = sp . zeros ( 12 , dtype = sp . double ) y = sp . zeros ( 12 , dtype = sp . double ) z = sp . zeros ( 12 , dtype = sp . double ) u = sp . zeros ( 12 , dtype = sp . double ) v = sp . zeros ( 12 , dtype = sp . double ) w = sp . zeros ( 12 , dtype = sp . double ) conec = [ 0 , 1 , - 1 , \\ 1 , 2 , - 1 , \\ 2 , 3 , - 1 , \\ 3 , 0 , - 1 , \\ 4 , 5 , - 1 , \\ 5 , 6 , - 1 , \\ 6 , 7 , - 1 , \\ 7 , 4 , - 1 , \\ 0 , 4 , - 1 , \\ 1 , 5 , - 1 , \\ 2 , 6 , - 1 , \\ 3 , 7 ] x = xyz [ conec , 0 ] y = xyz [ conec , 1 ] z = xyz [ conec , 2 ] x [ 2 :: 3 ] = sp . nan y [ 2 :: 3 ] = sp . nan z [ 2 :: 3 ] = sp . nan factor = 1. u = xyz [ conec , 0 ] + factor * uu [ conec , 0 ] v = xyz [ conec , 1 ] + factor * uu [ conec , 1 ] w = xyz [ conec , 2 ] + factor * uu [ conec , 2 ] u [ 2 :: 3 ] = sp . nan v [ 2 :: 3 ] = sp . nan w [ 2 :: 3 ] = sp . nan ax . plot ( x , y , z , \"-ob\" ) ax . plot ( u , v , w , \"-or\" ) plt . show () A simple extension to the above example generalizes the stack to an arbitrary number of bricks. And the visualization just works. Currently, I have to manually compile a python module extension on my Ubuntu linux laptop for this to work. I have no idea if it will be available to windows users as an easy-to-download binary in the near future. I will post on how to get this working on linux though. For those of you adventurous enough.","tags":"Blog","url":"https://joseabell.com/posts/2017/opensees-coming-to-python.html","loc":"https://joseabell.com/posts/2017/opensees-coming-to-python.html"},{"title":"Finite Elements for Shallow Water Equations","text":"$$ \\newcommand{\\pare}[1]{\\left( #1 \\right)} \\newcommand{\\brak}[1]{\\left[ #1 \\right]} \\newcommand{\\brac}[1]{\\left\\lbrace #1 \\right\\rbrace} \\newcommand{\\absol}[1]{\\left\\vert #1 \\right\\vert} \\newcommand{\\overbar}[1]{\\mkern 1.5mu\\overline{\\mkern-1.5mu#1\\mkern-1.5mu}\\mkern 1.5mu} \\newcommand{\\EE}[1]{\\times 10&#94;{#1}} \\newcommand{\\eqand}{\\, \\text{and} \\,} \\newcommand{\\qeqand}{\\quad \\text{and} \\quad} \\newcommand{\\qqeqand}{\\qquad \\text{and} \\qquad} \\newcommand{\\HRule}{\\rule{\\linewidth}{0.2mm}} \\newcommand{\\vect}[1]{\\boldsymbol{#1}} \\newcommand{\\uv}[1]{\\hat{\\boldsymbol{#1}}} \\newcommand{\\ud}{\\,\\mathrm{d}} \\newcommand{\\matorvec}[2]{\\left[\\begin{array}{#1} #2\\end{array}\\right]} \\newcommand{\\pardiff}[2]{\\dfrac{\\partial\\, #1}{\\partial\\, #2}} \\newcommand{\\pp}[2]{\\frac{\\partial #1}{\\partial #2}} \\newcommand{\\totdiff}[2]{\\dfrac{\\ud #1}{\\ud #2}} \\newcommand{\\rint}{\\pare{R}\\hspace{-0.5em} \\int } \\newcommand{\\expon}[1]{\\exp \\left\\lbrace #1 \\right\\rbrace} \\newcommand{\\unit}[1]{ \\, \\mathrm{#1} } \\newcommand{\\bunit}[1]{ \\, \\left[ \\mathrm{#1} \\right] } \\newcommand{\\funit}[2]{ \\, \\mathrm{ \\frac{#1}{#2} } } \\newcommand{\\bfunit}[2]{ \\, \\left[ \\mathrm{ {#1}/{#2} } \\right] } \\newcommand{\\mts}{\\bunit{m}} \\newcommand{\\cmts}{\\bunit{cm}} \\newcommand{\\mmts}{\\bunit{mm}} \\newcommand{\\kmts}{\\bunit{km}} \\newcommand{\\mps}{\\bfunit{m}{s}} \\newcommand{\\cmpt}{\\bfunit{cm}{s}} \\newcommand{\\mmps}{\\bfunit{mm}{s}} \\newcommand{\\kmps}{\\bfunit{km}{s}} \\newcommand{\\Newt}{\\bunit{N}} \\newcommand{\\kNewt}{\\bunit{kN}} \\newcommand{\\MNewt}{\\bunit{MN}} \\newcommand{\\Pa}{\\bunit{Pa}} \\newcommand{\\kPa}{\\bunit{kPa}} \\newcommand{\\MPa}{\\bunit{MPa}} \\newcommand{\\GPa}{\\bunit{GPa}} \\newcommand{\\kNmm}{\\bfunit{kN}{m&#94;2}} \\newcommand{\\Nmm}{\\bfunit{N}{m&#94;2}} \\newcommand{\\kgmmm}{\\bfunit{kg}{m&#94;3}} \\newcommand{\\Mgmmm}{\\bfunit{Mg}{m&#94;3}} \\newcommand{\\grcmcmcm}{\\bfunit{g}{cm&#94;3}} \\newcommand{\\kNmmm}{\\bfunit{kN}{m&#94;3}} \\newcommand{\\gr}{\\bunit{g}} \\newcommand{\\mgr}{\\bunit{mg}} \\newcommand{\\kgr}{\\bunit{kg}} \\newcommand{\\Mgr}{\\bunit{Mg}} \\newcommand{\\seg}{\\bunit{s}} \\newcommand{\\msec}{\\bunit{ms}} \\newcommand{\\musec}{\\bunit{\\mu s}} \\newcommand{\\mo}{\\bunit{month}} \\newcommand{\\mos}{\\bunit{months}} \\newcommand{\\days}{\\bunit{days}} \\newcommand{\\gs}{\\bunit{g}} \\newcommand{\\mss}{\\bfunit{m}{s&#94;2}} \\newcommand{\\cmss}{\\bfunit{cm}{s&#94;2}} \\newcommand{\\Hz}{\\bunit{Hz}} \\newcommand{\\MHz}{\\bunit{MHz}} \\newcommand{\\GHz}{\\bunit{GHz}} \\newcommand{\\THz}{\\bunit{THz}} \\newcommand{\\dgr}{\\unit{&#94;{\\circ}}} \\newcommand{\\rads}{\\bunit{rad}} \\newcommand{\\kips}{\\unit{kips}} \\newcommand{\\ksi}{\\unit{ksi}} \\newcommand{\\inch}{\\unit{in}} $$ The linear shallow water equations (SWE) are used extensively to model propagation of waves in situations where lateral domain dimensions are much greater than fluid height and, at the same time, wave perturbation height are much smaller than the fluid height. This finds useful applications in the case of tsunami-wave propagation modeling in deep-sea. The equations, after heavy linearization, are given by: $$\\begin{aligned} \\pardiff{u}{t} - f v = -g \\pardiff{h}{x} \\\\ \\pardiff{v}{t} + f v = -g \\pardiff{h}{y} \\\\ \\pardiff{h}{t} = -H \\pare{ \\pardiff{u}{x} + \\pardiff{v}{y} }\\end{aligned}$$ Where \\(u\\) is the speed in \\(x\\) direction. \\(v\\) is the speed in \\(y\\) direction. \\(h\\) wave perturbation height. (Free surface is at \\(h+H\\) ) \\(f\\) Coriolis force, given by: $$\\begin{aligned} f = 2 \\Omega \\sin \\phi \\end{aligned}$$ where \\(\\Omega\\) is Earth's angular velocity ( \\(\\pi/12 \\, \\brak{\\mathrm{rad/h}}\\) ) and \\(\\phi\\) is latitude. \\(g\\) acceleration due to gravity at given point in Earth. \\(H\\) fluid free surface height at repose. To complete the formulation, appropriate boundary conditions are needed. These equations will be discretized using Galerkin finite-element formulation. For this purpose we will be using the first order triangle finite element (see Felippa's chapter 15 here for basic notation and details regarding triangular shape functions). The SWE represent the space-time evolution of three scalar fields, namely \\(h\\) , \\(u\\) , and \\(v\\) . These three independent variables are the 3 degrees-of-freedom (DOF) of the problem. Therefore, each node will have information about these three DOFs. Using the basic 3-node triangle with interpolation functions given by the triangular coordinates (see Felippa IFEM Ch. 15 and this for more info), these fields are interpolated as follows. $$\\begin{aligned} h = \\sum N_i h_i = \\vect{N} \\vect{h} = \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\matorvec{c}{h_1\\\\h_2\\\\h_3} \\\\ u = \\sum N_i u_i = \\vect{N} \\vect{u} = \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\matorvec{c}{u_1\\\\u_2\\\\u_3} \\\\ v = \\sum N_i v_i = \\vect{N} \\vect{v} = \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\matorvec{c}{v_1\\\\v_2\\\\v_3} \\end{aligned}$$ Where \\(\\zeta_i\\) are triangular coordinates and \\(u_i\\) , \\(v_i\\) , and \\(h_i\\) the nodal values of the scalar fields at node \\(i\\) . As typical, we multiply the equations by a trial shape function \\(N_j\\) and integrate over the domain of the element \\(\\Omega&#94;e\\) , carrying out integration by parts. We arrive at the weak form of the SWE. $$\\begin{aligned} \\pare{ \\int_{\\Omega&#94;e} N_i N_j \\ud \\Omega&#94;e} \\dot{h}_j - \\pare{ \\int_{\\Omega&#94;e} H \\pardiff{N_i}{x} N_j \\ud \\Omega&#94;e} u_j - \\pare{ \\int_{\\Omega&#94;e} H \\pardiff{N_i}{y} N_j \\ud \\Omega&#94;e} v_j = 0 \\\\ \\pare{ \\int_{\\Omega&#94;e} N_i N_j \\ud \\Omega&#94;e} \\dot{u}_j - \\pare{ \\int_{\\Omega&#94;e} f N_i N_j \\ud \\Omega&#94;e} v_j + \\pare{ \\int_{\\Omega&#94;e} g N_i \\pardiff{N_j}{x} \\ud \\Omega&#94;e} h_j = 0 \\\\ \\pare{ \\int_{\\Omega&#94;e} N_i N_j \\ud \\Omega&#94;e} \\dot{v}_j + \\pare{ \\int_{\\Omega&#94;e} f N_i N_j \\ud \\Omega&#94;e} u_j + \\pare{ \\int_{\\Omega&#94;e} g N_i \\pardiff{N_j}{y} \\ud \\Omega&#94;e} h_j = 0 \\end{aligned}$$ Here, for the first order triangle, we simply have that 1 \\(N_i = \\zeta_i\\) . Defining the vector of nodal freedoms \\(\\vect{z}\\) as: $$\\begin{aligned} \\vect{z}&#94;T = \\matorvec{ccccccccc}{h_1 & h_2 & h_3 & u_1 & u_2 & u_3 & v_1 & v_2 & v_3 }&#94;T\\end{aligned}$$ The above equations can be re-written as follows: $$\\begin{aligned} \\matorvec{ccc} { \\vect{M} & \\vect{0} & \\vect{0} \\\\ \\vect{0} & \\vect{M} & \\vect{0} \\\\ \\vect{0} & \\vect{0} & \\vect{M} } \\dot{\\vect{z}} + \\matorvec{ccc} { \\vect{0} & -\\vect{K}_{hu} & -\\vect{K}_{hv} \\\\ \\vect{K}_{uh} & \\vect{0} & -\\vect{K}_{uv} \\\\ \\vect{K}_{vh} & \\vect{K}_{vu} & \\vect{0} } \\vect{z} = \\matorvec{c} { \\vect{0} \\\\ \\vect{0} \\\\ \\vect{0} } \\\\ \\vect{A} \\dot{\\vect{z}} + \\vect{B} \\vect{z} = \\vect{0}\\end{aligned}$$ Where the involved sub-matrices are given by the following matrix integrals: $$\\begin{aligned} & \\vect{M} = \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{hu} = \\int_{\\Omega&#94;e} H \\pare{\\pardiff{\\vect{N}}{x}}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{hv} = \\int_{\\Omega&#94;e} H \\pare{\\pardiff{\\vect{N}}{y}}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{uh} = \\int_{\\Omega&#94;e} g \\vect{N}&#94;T \\pardiff{\\vect{N}}{x} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{vh} = \\int_{\\Omega&#94;e} g \\vect{N}&#94;T \\pardiff{\\vect{N}}{y} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{uv} = \\int_{\\Omega&#94;e} f \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{vu} = \\int_{\\Omega&#94;e} f \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\end{aligned}$$ The derivatives \\(\\pardiff{\\vect{N}}{x}\\) y \\(\\pardiff{\\vect{N}}{y}\\) can be evaluated component-wise (again, see Felippa's work): $$\\begin{aligned} \\matorvec{c} { \\pardiff{N_i}{x} \\\\ \\pardiff{N_i}{y} } = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ x_{32} & x_{13} & x_{21} } \\matorvec{c} { \\pardiff{N_i}{\\zeta_1} \\\\ \\pardiff{N_i}{\\zeta_2} \\\\ \\pardiff{N_i}{\\zeta_3} }\\end{aligned}$$ For example, for \\(N_1\\) : $$\\begin{aligned} \\matorvec{c} { \\pardiff{N_1}{x} \\\\ \\pardiff{N_1}{y} } = \\matorvec{c} { \\pardiff{\\zeta_1}{x} \\\\ \\pardiff{\\zeta_1}{y} } = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ x_{32} & x_{13} & x_{21} } \\matorvec{c} { \\pardiff{\\zeta_1}{\\zeta_1} \\\\ \\pardiff{\\zeta_1}{\\zeta_2} \\\\ \\pardiff{\\zeta_1}{\\zeta_3} } = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ x_{32} & x_{13} & x_{21} } \\matorvec{c} { 1 \\\\ 0 \\\\ 0 } = \\dfrac{1}{2A} \\matorvec{c} { y_{23} \\\\ x_{32} }\\end{aligned}$$ It is clear that, therefore $$\\begin{aligned} \\pardiff{\\vect{N}}{x} = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} } \\\\ \\pardiff{\\vect{N}}{y} = \\dfrac{1}{2A} \\matorvec{ccc} { x_{32} & x_{13} & x_{21} }\\end{aligned}$$ Note that these derivatives are constant within each trinagle (hence the name, constant strain triangle although the interpretation is not strain in this case). In this context we have that \\(x_{ij} = x_i - x_j\\) where \\(x_i\\) is the \\(x\\) coordinate of the \\(i\\) -th element node. Similarly for \\(y_{ij} = y_i - y_j\\) . If we further assume that the gravity field \\(g\\) , the local depth at the finite element and the Coriolis force \\(f\\) are constant (probably a bad assumption for this variable for some applications which span the globe) within an element we can further reduce the discretized equations to: $$\\begin{aligned} \\vect{I}_{1} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ \\vect{I}_{2} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{x} \\ud \\Omega&#94;e \\\\ \\vect{I}_{3} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{y} \\ud \\Omega&#94;e\\end{aligned}$$ Working on the first integral $$\\begin{aligned} \\vect{I}_1 &= \\int_{\\Omega&#94;e} \\matorvec{c}{ \\zeta_1 \\\\ \\zeta_2 \\\\ \\zeta_3 } \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\ud \\Omega&#94;e\\\\ &= \\int_{\\Omega&#94;e} \\matorvec{ccc} { {\\zeta_1}&#94;2 & \\zeta_2\\zeta_1 & \\zeta_3 \\zeta_1 \\\\ \\zeta_1\\zeta_2 & {\\zeta_2}&#94;2 & \\zeta_3\\zeta_2 \\\\ \\zeta_1\\zeta_3 & \\zeta_2\\zeta_3 & {\\zeta_3}&#94;2 \\\\ } \\ud \\Omega&#94;e \\end{aligned}$$ We can use the following formula for the integration within a triangle of the monomials (again, from here ) $$\\begin{aligned} \\int_{\\Omega&#94;e} {\\zeta_1}&#94;p{\\zeta_2}&#94;q{\\zeta_2}&#94;r \\ud \\Omega&#94;e = \\dfrac{2 A p!\\, q!\\, r!}{\\pare{p+q+r+2}!}\\end{aligned}$$ With this, the integral for \\(\\vect{I}_1\\) is evaluated to $$\\begin{aligned} \\vect{I}_1 = \\dfrac{A}{12} \\matorvec{ccc} { 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 } \\end{aligned}$$ Proceeding with the next integral: $$\\begin{aligned} \\vect{I}_{2} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{x} \\ud \\Omega&#94;e \\\\ &= \\int_{\\Omega&#94;e} \\matorvec{c}{ \\zeta_1 \\\\ \\zeta_2 \\\\ \\zeta_3 } \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} } \\ud \\Omega&#94;e = \\int_{\\Omega&#94;e} \\matorvec{c}{ \\zeta_1 \\\\ \\zeta_2 \\\\ \\zeta_3 } \\ud \\Omega&#94;e \\cdot \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} }\\\\ \\end{aligned}$$ Utilizing the same identity as before to evaluate the integrals we arrive at: $$\\begin{aligned} \\vect{I}_2 = \\dfrac{A}{3} \\matorvec{c}{ 1 \\\\ 1 \\\\ 1 }\\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} } = \\dfrac{1}{6} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ y_{23} & y_{31} & y_{12} \\\\ y_{23} & y_{31} & y_{12} }\\end{aligned}$$ Analogously for \\(\\vect{I}_3\\) we have: $$\\begin{aligned} \\vect{I}_{3} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{y} \\ud \\Omega&#94;e = \\dfrac{1}{6} \\matorvec{ccc} { x_{32} & x_{13} & x_{21} \\\\ x_{32} & x_{13} & x_{21} \\\\ x_{32} & x_{13} & x_{21} }\\end{aligned}$$ And finally we can write the sub-matrices as follows. $$\\begin{aligned} \\vect{M} &= \\vect{I}_1 \\\\ \\vect{K}_{hu} &= H \\cdot {\\vect{I}_2}&#94;T & \\vect{K}_{hv} &= H \\cdot {\\vect{I}_3}&#94;T \\\\ \\vect{K}_{uh} &= g \\cdot \\vect{I}_2 & \\vect{K}_{vh} &= g \\cdot \\vect{I}_3 \\\\ \\vect{K}_{uv} &= f \\cdot \\vect{I}_1 & \\vect{K}_{vu} &= f \\cdot \\vect{I}_1 \\end{aligned}$$ Which can be replaced into $$\\begin{aligned} \\matorvec{ccc} { \\vect{M} & \\vect{0} & \\vect{0} \\\\ \\vect{0} & \\vect{M} & \\vect{0} \\\\ \\vect{0} & \\vect{0} & \\vect{M} } \\dot{\\vect{z}} + \\matorvec{ccc} { \\vect{0} & -\\vect{K}_{hu} & -\\vect{K}_{hv} \\\\ \\vect{K}_{uh} & \\vect{0} & -\\vect{K}_{uv} \\\\ \\vect{K}_{vh} & \\vect{K}_{vu} & \\vect{0} } \\vect{z} = \\matorvec{c} { \\vect{0} \\\\ \\vect{0} \\\\ \\vect{0} } \\\\ \\vect{A} \\dot{\\vect{z}} + \\vect{B} \\vect{z} = \\vect{0}\\end{aligned}$$ to generate the discretized SWE. A future post will discuss the python implementation of this finite element and its application to a basic problem.","tags":"Teaching","url":"https://joseabell.com/posts/2016/finite-elements-for-shallow-water-equations.html","loc":"https://joseabell.com/posts/2016/finite-elements-for-shallow-water-equations.html"},{"title":"Talk Given at IngeoKring 2016 - Physics-Based Earthquake-Soil-Structure Interaction for Near-Field Induced Seismicity","text":"This is a talk given at the IngeoKring 2016 Autumn symposium, hosted at TU Delft.","tags":"ResearchHighlight","url":"https://joseabell.com/posts/2016/talk-given-at-ingeokring-2016-ESSI-DRM.html","loc":"https://joseabell.com/posts/2016/talk-given-at-ingeokring-2016-ESSI-DRM.html"},{"title":"Paralelism in the RealESSI Simulator","text":"by: José Abell Paralelism in the RealESSI Simulator Introduction The Real ESSI Simulator [ 1 and 2 ] is a system for simulation of ESSI (Earthquake-Soil-Structure Interaction) problems developed at the UC Davis computational geomechanics group CompGeoMech . The main program is a parallel object-oriented finite element analysis (FEA) software for non-linear time domain analysis of ESSI systems. The program is written in C++, using several external libraries to accomplish its goals, most notably OpenMPI (message passing interface) is used to achieve parallelism. Other libraries used within ESSI include: PETSc for parallel solution of system of equations, METIS and Par-METIS for graph partitioning, HDF5 for output. Input is controlled by a custom domain-specific language designed by me specifically for this program. The software is meant to target a range of platforms from personal computers (desktop, laptop) to high-performance clusters and supercomputers. Parallelism in FEA (Left and middle) Nuclear power plant model showing different areas, (right) domain decomposition of model. Two main sources of parallelism can be identified in the context of nonlinear, dynamic finite element simulation: (i) system of equation solution and (ii) element-level constitutive integration. The first of these consists in the solution of a large linear system of equations (SOE) which arises from the discretization of the continuum problem (expressed as a set of coupled partial differential equations) in the spatial domain. The second source, comes from advancing the constitutive rate equations within each element once a global displacement increment is obtained from the solution of the SOE. This last part can account for a large part of the computational time for large problems and is embarrassingly parallel. An additional source of parallelism in ESSI simulations is the storage of the large ammounts of output generated by these simulations. The philosophy adopted by the ESSI simulator is to independently store the information necessary to build the model and restart the simulation at any given point. This gives rise to possibly terabytes of data in even modest models, with the additional problem on how to handle this. In ESSI this is done by using a network filesystem (NFS) to create a virtual parallel unique disk and the HDF5 format to store the data. In a nutshell, HDF5 implements a format for storing scientific (array-oriented) data in a portable way, and also allowing parallel read/write (it uses MPI I/O under the hood). A particularity of non-linear (plasticity based) FEA simulation is the unknown parts of the domain may plastify during simulations, leading to increased time spent integrating constitutive equations in that portion of the domain. What this implies is that, given an initial partition that balances the loading, this partition might become unbalanced if the domain plastifies. An adaptation of the dynamic domain decomposition method termed the \"plastic domain decomposition\"[ 3 ] or PDD, which achieves computational load re-balancing by repartitioning the element graph using computational time as one of the weighting factors. Implementation of Parallel Paradigms in RealESSI PDD is implemented in ESSI using the Actor/Shadow model of concurrency. Actors are autonomous and concurrently executing objects which execute asynchronously. Actors can create new actors and can send messages to other actors. The Actor model is an Object-Oriented version of message passing in which the Actors represent processes and the methods sent between Actors represent communications (verbatim from [ 4 ]). Shadow-actors are the means in which actors communicate. Shadow-actors are objects which represent each running actor (remote) in a particular machine's local address space. Shadow actors are in charge of transmitting and receiving messages from other actors and effectively encapsulate all MPI calls. In the object-oriented design of ESSI this model allows reuse of code and modularity when programming using MPI. References Boris Jeremić, Robert Roche-Rivera, Annie Kammerer, Nima Tafazzoli, Jose Abell M., Babak Kamranimoghaddam, Federico Pisano, ChangGyun Jeong and Benjamin Aldridge The NRC ESSI Simulator Program, Current Status in Proceedings of the Structural Mechanics in Reactor Technology (SMiRT) 2013 Conference, San Francisco, August 18-23, 2013. Boris Jeremić, Guanzhou Jie, Matthias Preisig and Nima Tafazzoli. Time domain simulation of soil-foundation-structure interaction in non-uniform soils. Earthquake Engineering and Structural Dynamics, Volume 38, Issue 5, pp 699-718, 2009. Boris Jeremić and Guanzhou Jie. Plastic Domain Decomposition Method for Parallel Elastic–Plastic Finite Element Computations in Geomechanics Report UCD CompGeoMech 03–2007. Lecture Notes on Computational Geomechanics: Inelastic Finite Elements for Pressure Sensitive Materials, UC Davis, CompGeoMech group","tags":"Tools","url":"https://joseabell.com/posts/2016/paralelism-in-the-realessi-simulator.html","loc":"https://joseabell.com/posts/2016/paralelism-in-the-realessi-simulator.html"},{"title":"CS261 - HW # 0 : Describe a parallel application","text":"by: José Abell Biography I am a PhD student at UCDavis CompGeoMech since Sept 2011, working on our in-house high-performance FEM simulation system. I come from Chile, where I did my undergraduate studies in structural engineering, leading to a professional degree in the specialty, at Pontificia Universidad Católica de Chile. Then, I proceeded to do my MS at the same institution in Civil Engineering. My MS thesis was more focused into the hazard part of earthquake engineering. My current research focuses on high-performance Earthquake-Soil-Structure interaction (ESSI) simulation. In a nutshell, it consists in modeling the effect of earthquake on structures from the earthquake source rupture process all the way up to a structure and its contents. The idea is to find out how and when a more accurate ESSI simulation yields different results from what is currently done in practice, and if this leads to safer and more economical designs. Parallel, high-performance computing is an enabling technology in this endeavor and there are many opportunities along the process where leveraging parallelism is possible. Meshing, simulation, and post-processing are important examples of these. Out of CS261 is would like to get insight into what it takes to get extreme-performance out of simulation software in different architectures. In particular, I would like to know more about the following topics: MPI usage patterns, how they come up, when to apply them, and tradeoffs. Shared memory parallel programming models (pthreads, OpenMP) and recurring software patterns. Parallel I/O techniques. Application: ESSI Simulator Introduction The Real ESSI Simulator [ 1 and 2 ] is a system for simulation of ESSI problems developed at UC Davis. It consists of software, hardware (a parallel computer: ESSI simulator machine), and documentation covering theory, usage and examples for the system. ESSI program is a parallel object-oriented finite element analysis (FEA) software for non-linear time domain analysis of ESSI systems. The program is written in C++, using several external libraries to accomplish its goals, most notably OpenMPI (message passing interface) is used to achieve parallelism. Other libraries used within ESSI include: PETSc for parallel solution of system of equations, METIS and Par-METIS for graph partitioning, [HDF5]phdf5 for parallel output. Input is controlled by a custom domain-specific language designed specifically for this program. The software is meant to target a range of platforms from personal computers (desktop, laptop) to high-performance clusters and supercomputers. Parallelism in FEA (Left and middle) Nuclear power plant model showing different areas, (right) domain decomposition of model. Two main sources of parallelism can be identified in the context of nonlinear, dynamic finite element simulation: (i) system of equation solution and (ii) element-level constitutive integration. The first of these consists in the solution of a large linear system of equations (SOE) which arises from the discretization of the continuum problem (expressed as a set of coupled partial differential equations) in the spatial domain. The second source, comes from advancing the constitutive rate equations within each element once a global displacement increment is obtained from the solution of the SOE. This last part can account for a large part of the computational time for large problems and is embarrassingly parallel. An additional source of parallelism in ESSI simulations is the storage of the large ammounts of output generated by these simulations. The philosophy adopted by the ESSI simulator is to independently store the information necessary to build the model and restart the simulation at any given point. This gives rise to possibly terabytes of data in even modest models, with the additional problem on how to handle this. In ESSI this is done by using a network filesystem (NFS) to create a virtual parallel unique disk and the HDF5 format to store the data. In a nutshell, HDF5 implements a format for storing scientific (array-oriented) data in a portable way, and also allowing parallel read/write (it uses MPI I/O under the hood). A particularity of non-linear (plasticity based) FEA simulation is the unknown parts of the domain may plastify during simulations, leading to increased time spent integrating constitutive equations in that portion of the domain. What this implies is that, given an initial partition that balances the loading, this partition might become unbalanced if the domain plastifies. An adaptation of the dynamic domain decomposition method termed the \"plastic domain decomposition\"[ 3 ] or PDD, which achieves computational load re-balancing by repartitioning the element graph using computational time as one of the weighting factors. Brief design description PDD is implemented in ESSI using the Actor/Shadow model of concurrency. Actors are autonomous and concurrently executing objects which execute asynchronously. Actors can create new actors and can send messages to other actors. The Actor model is an Object-Oriented version of message passing in which the Actors represent processes and the methods sent between Actors represent communications (verbatim from [ 4 ]). Shadow-actors are the means in which actors communicate. Shadow-actors are objects which represent each running actor (remote) in a particular machine's local address space. Shadow actors are in charge of transmitting and receiving messages from other actors and effectively encapsulate all MPI calls. In the object-oriented design of ESSI this model allows reuse of code and modularity when programming using MPI. Performance As seen in [ 3 ], plastic-domain-decomposition method provides a viable way to re-balance a plastifying domain and has seen a reasonable scaling for low number of processes. A comprehensive scaling study on different platforms has not been yet performed. Currently, ESSI's parallelization is exclusively done using MPI. This implies that for the lower end of the platforms we intend to cover (PCs, laptops) there is a performance hit due to improper use of shared memory architecture. This problem could be solved using a mixed design with threads for shared memory nodes and MPI for network. Another big bottleneck currently present is that all input is loaded into the master process, partitioned and then distributed. This results in an unnecessary load to the main process at startup and imposes a cap on how big a model might be solved. In order to solve this issue the parser must be parallelized to some extent, so that different (pre-partitioned) model parts can be loaded into different processors on startup. References Boris Jeremić, Robert Roche-Rivera, Annie Kammerer, Nima Tafazzoli, Jose Abell M., Babak Kamranimoghaddam, Federico Pisano, ChangGyun Jeong and Benjamin Aldridge The NRC ESSI Simulator Program, Current Status in Proceedings of the Structural Mechanics in Reactor Technology (SMiRT) 2013 Conference, San Francisco, August 18-23, 2013. Boris Jeremić, Guanzhou Jie, Matthias Preisig and Nima Tafazzoli. Time domain simulation of soil-foundation-structure interaction in non-uniform soils. Earthquake Engineering and Structural Dynamics, Volume 38, Issue 5, pp 699-718, 2009. Boris Jeremić and Guanzhou Jie. Plastic Domain Decomposition Method for Parallel Elastic–Plastic Finite Element Computations in Geomechanics Report UCD CompGeoMech 03–2007. Lecture Notes on Computational Geomechanics: Inelastic Finite Elements for Pressure Sensitive Materials, UC Davis, CompGeoMech group","tags":"CS261 Homeworks","url":"https://joseabell.com/posts/2015/cs261-hw-0-describe-a-parallel-application.html","loc":"https://joseabell.com/posts/2015/cs261-hw-0-describe-a-parallel-application.html"},{"title":"Simulation of a surface wave (Rayleigh)","text":"This simulation, done in the UCD ESSI simulator and visualized in VisIt using VisIt-ESSI plugin, shows the passage of a surface wave (Rayleigh wave). The simulation consists on a surface impact on an elastic domain of 900m by 1800m depth, and a shear wave velocity of 1000km/s. Elliptical-retrograde motion can be seen as an illustration of Rayleigh waves. VisIt can be obtained here , and the plugin here .","tags":"ResearchHighlight","url":"https://joseabell.com/simulation-of-a-surface-wave-English.html","loc":"https://joseabell.com/simulation-of-a-surface-wave-English.html"},{"title":"Visualizing ESSI output with VisIt-ESSI","text":"VisIt-ESSI is a plugin for the VisIt post-processor created my CompGeoMech. It allows for remote (soon parallel also) visualization of outputs produced by ESSI in the HDF5 format (*.h5.feioutput). VisIt can be obtained here , and the plugin here .","tags":"Tutorials","url":"https://joseabell.com/visualizing-essi-output-with-visit-essi-English.html","loc":"https://joseabell.com/visualizing-essi-output-with-visit-essi-English.html"},{"title":"NTS-02. On Rayleigh damping coefficients for FE analysis","text":"Note to self. How to compute Rayleigh damping coefficients for given damping ratios $\\xi_1$ and $\\xi_2$ at frequencies $f_1$ and $f_2$. This is textbook content, I just need to remind myself too often how this is done and end up re-deriving the equations. Given the second-order system of differential equations representing the FE model $$ M \\ddot{u} + C \\dot{u} + K u = F(t) $$ The damping matrix $C$ can be written as a Rayleigh damping matrix: $$ C = a_0 M + a_1 K $$ $a_0$ and $a_1$ are Rayleigh damping coefficients found by solving $$ \\left[ \\begin{array}{cc} \\dfrac{1}{2\\pi f_1} & 2 \\pi f_1 \\\\ \\dfrac{1}{2\\pi f_2} & 2 \\pi f_2 \\end{array} \\right] \\left[ \\begin{array}{c} a_0 \\\\ a_1 \\end{array} \\right] = \\left[ \\begin{array}{c} \\xi_1 \\\\ \\xi_2 \\end{array} \\right] $$ Which I do in the following code: In [6]: import sympy as sym xi1 = sym . S ( \"xi_1\" ) xi2 = sym . S ( \"xi_2\" ) xi = sym . S ( \"xi\" ) f1 = sym . S ( \"f_1\" ) f2 = sym . S ( \"f_2\" ) w1 = 2 * sym . pi * f1 w2 = 2 * sym . pi * f2 A = sym . Matrix ([[ 1 / w1 , w1 ],[ 1 / w2 , w2 ]]) / 2 b = sym . Matrix ([[ xi1 ],[ xi2 ] ]) a = A **- 1 * b print sym . pretty ( sym . simplify ( a [ 0 ])) print sym . simplify ( a [ 0 ]) print sym . pretty ( sym . simplify ( a [ 1 ])) print sym . simplify ( a [ 1 ]) 4⋅π⋅f₁⋅f₂⋅(f₁⋅ξ₂ - f₂⋅ξ₁) ───────────────────────── 2 2 f₁ - f₂ 4*pi*f_1*f_2*(f_1*xi_2 - f_2*xi_1)/(f_1**2 - f_2**2) f₁⋅ξ₁ - f₂⋅ξ₂ ───────────── ⎛ 2 2⎞ π⋅⎝f₁ - f₂ ⎠ (f_1*xi_1 - f_2*xi_2)/(pi*(f_1**2 - f_2**2)) $$ a_0 = \\frac{4 \\pi f_{1} f_{2}}{f_{1}&#94;{2} - f_{2}&#94;{2}} \\left(f_{1} \\xi_{2} - f_{2} \\xi_{1}\\right) $$$$ a_1 = \\frac{f_{1} \\xi_{1} - f_{2} \\xi_{2}}{\\pi \\left(f_{1}&#94;{2} - f_{2}&#94;{2}\\right)} $$ Damping at other frequencies is given by, $$ \\xi(f) = \\dfrac{a_0}{2\\pi f} + \\pi a_1 f $$ For example for $f_1 = 0.3$ Hz and $f_2 = 1.2$ Hz, and $\\xi_1 = 0.05$, $\\xi_2 = 0.02$. In [25]: import scipy as sp import matplotlib.pyplot as plt f_1 = 0.3 f_2 = 1.2 xi_1 = 0.05 xi_2 = 0.02 a_0 = 4 * pi * f_1 * f_2 * ( f_1 * xi_2 - f_2 * xi_1 ) / ( f_1 ** 2 - f_2 ** 2 ) a_1 = ( f_1 * xi_1 - f_2 * xi_2 ) / ( pi * ( f_1 ** 2 - f_2 ** 2 )) f = sp . linspace ( 0.0001 , 3 , 100 ) xi = a_0 / ( 4 * pi * f ) + pi * a_1 * f plt . figure () . set_size_inches ([ 12 , 6 ], forward = True ) plt . plot ( f , xi * 100 , linewidth = 2 ) plt . plot ( f_1 , xi_1 * 100 , \"ro\" ) plt . plot ( f_2 , xi_2 * 100 , \"ro\" ) plt . xlabel ( r \"$f$\" ) plt . ylabel ( r \"Damping Ratio, $\\xi$, [ % o f critical]\" ) plt . ylim ([ 0 , 10 ]) plt . grid ()","tags":"ipython_notebooks","url":"https://joseabell.com/posts/2014/nts-02-rayleigh-damping.html","loc":"https://joseabell.com/posts/2014/nts-02-rayleigh-damping.html"},{"title":"Testing IPython Notebook integration into Pelican","text":"In this post I'll make a small example meant to test the IPython notebook + Pelican integration thanks to the plugin created by danielfrg that can be found here . Lets start out with some basic plotting! In [1]: x = linspace ( 0 , 1 , 1000 ) y = x ** 2 * sin ( 6 * pi * x ) plot ( x , y ) Out[1]: [<matplotlib.lines.Line2D at 0x2ff0d10>] Looks like everything is working fine. Let's try using XKCD plotting format! :) In [3]: xkcd () plot ( x , y + 1 ) xlabel ( \"Abscissa\" ) ylabel ( \"Ordinate\" ) Out[3]: <matplotlib.text.Text at 0x3531590> Cool! We're going to do some serious blogging now. In [ ]:","tags":"ipython_notebooks","url":"https://joseabell.com/posts/2014/test_ipythonnb_plugin.html","loc":"https://joseabell.com/posts/2014/test_ipythonnb_plugin.html"},{"title":"SNE # 01. Example of ESSI simulation and visualization with visitESSI","text":"These are the results of a simple elastic-domain simulation. Mesh consists of 154523 Nodes (46359 DOFs) 1250 27 node bricks (LT formulation) 1200 time-steps (dt = 0.01s) Results were stored in the new format of output for ESSI simulator and visualized in VisIt post-processor where the movie was created.","tags":"Small Numerical Experiments","url":"https://joseabell.com/posts/2014/sne-01-example-of-essi-simulation-and-visualization-with-visitessi.html","loc":"https://joseabell.com/posts/2014/sne-01-example-of-essi-simulation-and-visualization-with-visitessi.html"},{"title":"NTS (Note-To-Self): Creating dynamically linked libraries","text":"A nice extensive tutorial can be found here . In a nutshell: gcc -Wall -fPIC -c \\*.c gcc -shared -Wl,-soname,libctest.so.1 -o libctest.so.1.0 \\*.o mv libctest.so.1.0 /opt/lib ln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so.1 ln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so -Wall : include warnings. See man page for warnings specified. -fPIC : Compiler directive to output position independent code, a characteristic required by shared libraries. Also see \"-fpic\". -shared : Produce a shared object which can then be linked with other objects to form an executable. -Wl,options : Pass options to linker. In this example the options to be passed on to the linker are: -soname libctest.so.1 . The name after the -o option is passed to gcc. Option -o : Output of operation. In this case the name of the shared object to be output will be libctest.so.1.0 See note on \"Library Paths\"","tags":"NTS","url":"https://joseabell.com/posts/2013/nts-note-to-self-creating-dynamically-linked-libraries.html","loc":"https://joseabell.com/posts/2013/nts-note-to-self-creating-dynamically-linked-libraries.html"},{"title":"SNE # 0. Stochastic inverse pendulum","text":"This is the first installment of \"Small Numerical Experiments\" (SNE), a section where I upload and comment (briefly) some small numerical example. The purpose is to prove a point to myself, test some code, ideas, etc. In this first post I will explore the response of a stochastic inverse pendulum. What I mean in this case is an inverse pendulum (shown left) with a random initial condition. The purpose is to obtain the time-evolving probability density function (PDF) of the pendulum's position. I will be doing Monte-Carlo simulations to obtain an approximation to this PDF. The response of the system is governed by the following nonlinear ordinary differential equation in terms of the angular displacement \\(\\theta\\) with respect to the vertical: $$ m l&#94;2 \\ddot{\\theta} + c \\dot{\\theta} - mgl \\sin \\theta = 0 $$ Subject to an initial condition $$ \\theta(0) = \\theta_0$$ and $$ \\dot{\\theta}(0) =\\dot{\\theta}_0$$ . In this case, the initial angular velocity is set to zero and the initial angular displacement is set to have a Gaussian random distribution with mean zero and standard deviation of 10 degrees. The linear damping constant is set to 10% critical damping the system would have in the case of small oscillations about the final equilibrium point $$\\theta = 180&#94;{\\circ}$$ . The example is coded in python and solved using the odeint solver available in scipy . Here is an example response for a given nonzero initial condition. Doing 5000 Monte-Carlo draws and plotting all the responses together we get: -About half of the the pendulums swing to the left and the other half to the right. This would result in a bimodal distribution and is a mere artifact of the mathematical model used. Indeed, what the model perceives as two distinct equilibrium points are actually the same position for the pendulum. This arises because of the periodicity in the \\(\\sin()\\) function. From this set of motions a PDF may be computed for each time and animated to show the evolution of the PDF with time. The bimodal distribution obtained at the end is, therefore, an artifact, as the peaks correspond to the same final configuration for the system. In a more complex case it might not be possible to distinguish between peaks in PDFs which are real, ie. correspond to physically different configurations, from those that arise from deficiencies in the mathematical tool used. These spurious peaks generate unrealistic dispersion in the distribution of results. Is there a way to identify them and get rid of them? The following python code produces these results. # ! / bin / python # -*- coding : utf - 8 -*- # Small numerical experiments # 00 \"\"\" @SNE_number: 00 @Title: Stochastic inverse pendulum @Idea: Show a case in which bifurcation behavior produces multimodal distribution. @Tags: scipy, ode, stochastic, multimodal, bimodal, matplotlib, Monte-Carlo, animation, python @Date: Created on Fri Oct 4 2013 @author: jaabell \"\"\" import scipy as sp import matplotlib . pylab as plt from scipy . integrate import odeint N = 5000 # [] number of Monte - Carlo trials mu_theta = 0.0 # [ deg ] sigma_theta = 10 # [ deg ] tmax = 10 # [ s ] Maximum time for simulation dt = 0.01 # [ s ] Time step for integration m = 1 # [] g = 9.81 # [ m / s\\&#94; 2 ] l = 0.50 # [ m ] xi = 0.3 # [] Ratio of critical damping ( for a regular pendulum under small deflections ) Nbins = 50 # [] Number of bins for computing histograms theta_0_dot = 0.0 # [ deg / sec ] initial angular velocity for pendulums compute = False # Use this in an interactive session ( ie . spyder ) to avoid recomputing the Monte - Carlo runs c = 2 * xi * m * l** 2 # [ N * m * s / rad ] Damping constant Nt = int ( tmax / dt ) # [] Number of simulation timesteps # Generate parameters for Monte - Carlo trials mu_theta_rad = mu_theta * sp . pi / 180 sigma_theta_rad = sigma_theta * sp . pi / 180 thetas = sp . randn (( N )) * sigma_theta_rad + mu_theta_rad t = sp . arange ( 0 , tmax , dt ) # Recast problem as a set of first order ODEs b = - c/ ( m * l** 2 ) a = g / l def func ( y , t ) : return [ y [ 1 ], a * sp . sin ( y [ 0 ]) + b * y [ 1 ] ] def gradient ( y , t ) : return [[ 0.0 , 1.0 ],[ a * sp . cos ( y [ 0 ]), b ]] # Do the Monte - Carlo runs if compute : yall = sp . zeros (( Nt , N )) i = 0 for theta_0 in thetas : y0 = [ theta_0 * sp . pi / 180 , theta_0_dot * sp . pi / 180 ] y = odeint ( func , y0 , t , Dfun = gradient ) yall [ : , i ] = y [ : , 0 ] print \"Case {} of {}\" . format ( i , N ) i+= 1 # Some plotting ( animation after a tutorial found in http : // jakevdp . github . io / blog / 2012 / 08 / 18 / matplotlib - animation - tutorial/ ) # Also look at http : // matplotlib . org / api / animation_api . html plt . close ( \"all\" ) from matplotlib import animation # First set up the figure , the axis , and the plot element we want to animate fig = plt . figure () ax = plt . axes ( xlim= ( - 300 , 300 ), ylim= ( 0 , 10 )) ax . grid () ax . set_xticks ( sp . linspace ( - 270 , 270 , num = 7 )) ax . set_xlabel ( \"$\\\\\\theta$\" ) ax . set_ylabel ( \"$f_{\\\\\\theta}(\\\\\\theta, t)$\" ) line , = ax . plot ([], [], lw = 2 ) time_text = ax . text ( - 270 , 9 , '' ) # , transform = ax . transAxes ) from scipy . interpolate import interp1d probability_thresholds = sp . linspace ( 0 , 1 , 21 ) def myhistogram ( y ) : yn = sp . array ( y ) yn . sort () cdf = sp . linspace ( 0 , 1 , yn . size ) y_bins = interp1d ( cdf , yn , kind='linear' , axis=- 1 , copy = True , bounds_error = True )( probability_thresholds ) return probability_thresholds , y_bins def init () : line . set_data ([],[]) time_text . set_text ( \"\" ) return line , time_text def animate ( i ) : cdf , y_bins = myhistogram ( yall [ i , : ]) pdf = sp . diff ( cdf ) / sp . diff ( y_bins ) y_bins_centers = 0.5 * ( y_bins [ 0 :- 1 ] + y_bins [ 1 :: ]) # pdf , y_bins = sp . histogram ( yall [ i , : ], bins = Nbins , density = True ) # y_bins_centers = 0.5 * ( y_bins [ 0 :- 1 ] + y_bins [ 1 :: ]) line . set_data ( y_bins_centers * 180 / sp . pi , pdf ) time_text . set_text ( \"Time = {0:4.2f} s\" . format ( t [ i ])) return line , time_text anim = animation . FuncAnimation ( fig , animate , init_func = init , frames = 1000 , interval = 1 , blit = True ) #anim . save ( 'basic_animation.mp4' , fps = 30 , extra_args = [ '-vcodec' , 'libx264' ]) plt . show () #plt . figure () #plt . plot ( t , yall [ : , 0 ] * 180 / sp . pi ) #plt . grid () #plt . yticks ( sp . linspace ( - 270 , 270 , num = 13 )) #plt . xlabel ( \"$t$\" ) #plt . ylabel ( \"$\\\\\\theta(t)$\" )","tags":"Small Numerical Experiments","url":"https://joseabell.com/posts/2013/sne-0-stochastic-inverse-pendulum.html","loc":"https://joseabell.com/posts/2013/sne-0-stochastic-inverse-pendulum.html"}]};