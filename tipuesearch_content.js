var tipuesearch = {"pages":[{"title":"About","text":"I am a chilean professor working at Universidad de los Andes within the Civil Infrastructure Systems group of the School of Engineering and Applied Sciences . My research focuses on the study of linear and nonlinear structure-soil systems under earthquake loading, through modeling and simulation. An important aspect of my research is that I place strong emphasis on the correct description of seismic wave propagation from source to site. A major goal for me is to leverage the use of high-performance computing as the enabling technology that will allow the profession to move forward in terms of the power of analysis available to engineers. See also : Extended research statement . Publications . Teaching . Curriculum Vitae . Interesting Links . Information for Prospective Students .","tags":"misc","url":"https://joseabell.com/pages/01about.html","loc":"https://joseabell.com/pages/01about.html"},{"title":"Publications","text":"Google Scholar Journal Articles [ Accepted ] Haoyuan Liu, Andrea Diambra , José Antonio Abell , Federico Pisanò . Memory-enhanced plasticity modelling of sand behaviour under undrained cyclic loading . Journal of Geotech. and Geoenvironmental Eng. Patricio A. Moreno-Casas , Felipe Scott , José Delpiano , José A. Abell , Francisco Caicedo, Raúl Muñoz, and Alberto Vergara-Fernández . Mechanistic Description of Convective Gas–Liquid Mass Transfer in Biotrickling Filters Using CFD Modeling. Environmental Science & Technology 2020 54 (1), 419-426 Hao Yuan Liu, José Antonio Abell , Andrea Diambra , and Federico Pisanò. Modelling the cyclic ratcheting of sands through memory-enhanced bounding surface plasticity. Géotechnique 2019 69:9, 783-800 José. A. Abell , Nebojša Orbović, David B. McCallen and Boris Jeremić . Earthquake Soil Structure Interaction of Nuclear Power Plants, differences in response to 3-D, 3×1-D, and 1-D excitations. Earthquake Engineering and Structural Dynamics, in print, 2018. Catalina Fortuño, Juan Carlos de la Llera , Charles W. Wicks , and José A. Abell - Synthetic Hybrid Broadband Seismograms Based on InSAR Coseismic Displacements . Bulletin of the Seismological Society of America published ahead of print November 18, 2014, doi:10.1785/0120130293 José A. Abell , Juan Carlos de la Llera , Charles W. Wicks - Enhancement of long period components of recorded and synthetic ground motions using InSAR . Soil Dynamics and Earthquake Engineering 01/2011; 31(5):817-829 . DOI:10.1016/j.soildyn.2011.01.005 Conference Proceedings Yuan Feng, José Abell , Sumeet Kumar Sinha, Han Yang, Fatemah Behbehani, Hexian Wang, Nebojša Orbović, David B McCallen and Boris Jeremić . Verification for the Real ESSI Simulator . In proceedings of Structural Mechanics in Reactor Technology (SMiRT) 24 conference, Busan, South Korea, August 20-25, 2017. J. A. Abell , J. G. F. Crempien , and B. Jeremić - Physics-Based Scenario Modeling for Earthquake-Soil-Structure Interaction of Buildings in Proceedings of the 16th. World Conference on Earthquake Engineering, 2017. José Antonio Abell Mena , Sumeet Kumar Sinha, Boris Jeremić - Wavelet Based Synthetic Earthquake Sources for Path and Soil Structure Interaction Modeling: Stress Testing of Nuclear Power Plants Proceedings of IAEA conference on: Best Practices in Physics-based Fault Rupture Models for Seismic Hazard Assessment of Nuclear Installations, Vienna, Austria, November 1820, 2015 Nebojša Orbović, Boris Jeremić , José Antonio Abell Mena , Chao Luo, Robert P. Kennedy and Andrei Blaihoanu - Use of Nonlinear, Time Domain Analysis for Design of NPPs in Proceedings of the Structural Mechanics in Reactor Technology (SMiRT) 2015 Conference, Manchester, August 10-14, 2015. N.Tafazzoli, F. Pisanò , J. A. Abell M. , B. Kamrani, C.-G. Jeong, B. Aldridge, R. Roche, A. Kammerer, and B. Jeremic - * ESSI Simulator Program, Current Status* . Proceedings of the 22nd. Structural Mechanics in Reactor Technology (SMiRT 22) Conference, San Francisco, California, U.S.A. Ph.D. Dissertation Earthquake-Soil-Structure Interaction Modeling of Nuclear Power Plants for Near-Field Events - Ph.D. Dissertation - University of California at Davis, March 2016 Masters Thesis InSAR Compatible Ground Motions for Northern Chile - Masters Thesis - Pontificia Universidad Católica de Chile, August 2009","tags":"misc","url":"https://joseabell.com/pages/04publications.html","loc":"https://joseabell.com/pages/04publications.html"},{"title":"Tools","text":"Tools I've (Cr)eated/(Co)ntributed to OpenSees - (Co) UC Berkeley RealESSI Simulator - (Co) UCD Earthquake-Soil-Structure Interaction simulator system. FEI-Syntax-n-Snippets - (Cr) - Syntax highlighter and snippets for the Finite Element Interpreter (A domain specific language for FEA modelling within ESSI Simulator). visitESSI - (Cr) - A plugin for visualizing ESSI Simulator HDF5 output. gmshtranslator - (Cr) - A python parser for gmsh .msh format. I use it to create ESSI/OpenSees/whateverelse models. 3rd. Party tools I strive to stay as open source/free as I can with the tools I use. Every now and then, though, I will pay for a useful tool. Here is a set of apps I love to use day to day. Special thanks to their creators. Sublime Text - A very cool text editor. (Free to try, but have to buy to keep using) SciPy - Scientific computing for Python. The reason I switched from Matlab to Python! Mendeley - Oh how would I ever manage references without you dear mendeley? Code::Blocks - Open source, very powerful IDE for C++ projects. gmsh - Need to generate 3D FEM meshes? gmsh will do that and more. STLfilt - A filter for compiler output. Very useful when dealing with STL and template metaprogramming. Makes reading error reports very easy. LTensor - A high performance C++ library for dealing with tensors (up to rank 4) based on templates. Deal with tensors in C++ using natural notation ! ARM Forge - A parallel-debugger/profiler suite. There is really no open-source alternative that can provide the productivity these guys provide. Costly though. Inkscape - My dark alternate identity, a designer. Useful vector graphics editor to create beautiful illustrations. I also (cr)eated a syntax highlighter and \"snippets\" package for this editor for our FEI Finite Element simulation program (ESSI) [ here ]. Can be installed easily into sublime with Package Control plugin (FEI-syntax-n-snippets). Spyder - A very cool, Matlab inspired, python editor for scientific computing. I don't use this anymore, it was a catalyst for my transition from matlab to python. I do recommend it to my students and matlab-based colleagues. GIMP - The Gnu Image Manipulation Program. My designer side flourishing again. Blender - Used for cool 3-D viz and random art I do. As far as OSes go Ubuntu - What? There are other Linux distributions out there? elementary OS - Interesting and pretty Ubuntu-based linux distro. Inspired by mac. Virtual Box - Because sometimes you just need windows (because other people can't linux). Some useful commands .","tags":"misc","url":"https://joseabell.com/pages/05tools.html","loc":"https://joseabell.com/pages/05tools.html"},{"title":"Using my gmshtranslator python tool to interface gmsh with opensees.","text":"I wrote the gmshtranslator tool a while back during my PhD, to easily parse gmsh msh files to any other format. I've been using it for years now with not much change for both research and consulting, and have been contacted by other researchers that want to use it. I will soon write a tool, powered by gmshtranslator , to more easily translate from gmsh into OpenSees. Meanwhile, here is a short example on how to use gmshtranslator to create OpenSees models. The example assumes you know gmsh formats ( .geo and .msh ) and python. The example consists on the simple cantilever beam shown in the following figure. The beam is fixed at the right end, and has node-by-node forcing on the right end. The following gmsh .geo. script prepares the domain. beam.geo : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 LX = 5 ; LY = 0.5 ; Nx = 40 ; Ny = 5 ; Point ( 1 ) = { 0 , 0 , 0 , 1 }; Point ( 2 ) = { LX , 0 , 0 , 1 }; Point ( 3 ) = { LX , LY , 0 , 1 }; Point ( 4 ) = { 0 , LY , 0 , 1 }; Line ( 1 ) = { 1 , 2 }; Line ( 2 ) = { 2 , 3 }; Line ( 3 ) = { 3 , 4 }; Line ( 4 ) = { 4 , 1 }; Line Loop ( 1 ) = { 1 , 2 , 3 , 4 }; Plane Surface ( 1 ) = { 1 }; Transfinite Line { 1 , 3 } = Nx + 1 ; Transfinite Line { 2 , 4 } = Ny + 1 ; Transfinite Surface { 1 }; Recombine Surface { 1 }; Physical Line ( \"Fixed\" ) = { 4 }; Physical Line ( \"Forcing\" ) = { 2 }; Physical Surface ( \"Beam\" ) = { 1 }; Mesh ( 2 ); 3 physical groups are defined: fixed to identify the fixed nodes, forcing to identify the nodes that will carry loads, and beam contains all the quad elements to represent the body of the beam. Note the optional use of the transfinite meshing algorithm. Once this script is executed in gmsh the .msh file can be exported. The resulting .msh file can be found here . gmshtranslator parses the .msh file, executing code depending on certain user-defined rules. What we want to do is define an opensees node command for each node in the .msh file, fix the nodes contained in the fixed physical group, generate forces for the nodes in the forcing physical group, and add quad elements for each quad in the .msh file. First, import the beam.msh file into gmshtranslator and open files to be written that will contain the opensees code. 1 2 3 4 5 6 7 8 9 10 from gmshtranslator import gmshTranslator mshfname = \"beam.msh\" gt = gmshTranslator ( mshfname ) fid_nodes = open ( mshfname . replace ( \".msh\" , \".nodes.tcl\" ), \"w\" ) fid_elements = open ( mshfname . replace ( \".msh\" , \".elements.tcl\" ), \"w\" ) fid_fixities = open ( mshfname . replace ( \".msh\" , \".fixities.tcl\" ), \"w\" ) fid_loads = open ( mshfname . replace ( \".msh\" , \".loads.tcl\" ), \"w\" ) I like writing different things (nodes, elements, etc.) in separate files for debugging. Your style might be different. gmshtranslator parses the file and evaluates rules . A rule is composed of a condition that must be met and an action to be executed, these are both python functions. There are rules for nodes and for elements. The syntax for node and element conditions are: 1 2 def node_condition ( tag , x , y , z , physgroups ): def element_condition ( eletag , eletype , physgrp , nodes ): These are functions that evaluate to true or false depending on the inputs. Then the syntax for actions are: 1 2 def node_action ( tag , x , y , z ): def element_action ( eletag , eletype , physgrp , nodes ): These functions don't return anything, instead excecute whatever code should be executed if the condition of the rule is met. Rules are added to the parser by using the add_nodes_rule or add_elements_rule function of gmshtranslator and are excecuted whenever the parse() method is called. For example, the rule to add all nodes to the opensees domain would be: 1 2 3 4 5 6 7 def is_node ( tag , x , y , z , physgroups ): return True def add_node ( tag , x , y , z ): fid_nodes . write ( \"node {} {} {} \\n \" . format ( tag , x , y )) gt . add_nodes_rule ( is_node , add_node ) The node condition ( is_node ) function always returns true , that is this rule will execute for all nodes. The action function is add_node and will write the appropriate text into the nodes file. The rule is added into the parser by using the gt.add_nodes_rule function which accepts two python functions as arguments: a condition and an action. The code for the rest of the example is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def fix_node ( tag , x , y , z ): fid_fixities . write ( \"fix {} 1 1 \\n \" . format ( tag )) def add_load ( eletag , eletype , physgrp , nodes ): fid_loads . write ( \"load {} $fx $fy \\n \" . format ( nodes [ 0 ])) fid_loads . write ( \"load {} $fx $fy \\n \" . format ( nodes [ 1 ])) def add_element ( eletag , eletype , physgrp , nodes ): fid_elements . write ( \"element quad {} {} {} {} {} $thick PlaneStress $mat_tag \\n \" . format ( eletag , nodes [ 0 ], nodes [ 1 ], nodes [ 2 ], nodes [ 3 ])) gt . add_nodes_rule ( gt . is_node_in ( \"Fixed\" ), fix_node ) gt . add_elements_rule ( gt . is_element_in ( \"Forcing\" ), add_load ) gt . add_elements_rule ( gt . is_element_in ( \"Beam\" ), add_element ) Note that we didn't write a condition for the fix_node action, instead we used some of the simple conditions contained in gmshtranslator that can simplify some typical situations. In this case the gt.is_node_in() function takes a physical group name and evaluates whether each node is in that physical group. An equivalent python code for this would be: 1 2 3 Fixed = 1 # Physical group number assigned by gmsh to the 'Fixed' group def is_node_in_Fixed ( tag , x , y , z , physgroups ): return Fixed in physgroups Or using gmstranslator s internal mapping. 1 2 def is_node_in_Fixed ( tag , x , y , z , physgroups ): return gt . physical_groups_by_name [ 'Fixed' ] in physgroups \\ The same holds true for the add_load and add_element rules, I just opted to use the simple function but could have written a condition function from scratch. Add all rules to the parser by callig the add_X_rule functions. Finally, call parse to execute and generate all output files. 1 gt . parse () Don't forget to close files people! 1 2 3 4 fid_nodes . close () fid_elements . close () fid_fixities . close () fid_loads . close () Run the python script and, voillá! Meshing done. Finally, for completeness, here is the OpenSees tcl code that runs the complete example. I used elastic-isotropic material and a simple static analysis. I added only vertical loading on the tip of the beam. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 model BasicBuilder - ndm 2 - ndf 2 set thick 1.0 set mat_tag 1 set E 200 .e9 set nu 0.3 nDMaterial ElasticIsotropic $mat_tag $E $nu source \"beam.nodes.tcl\" source \"beam.fixities.tcl\" source \"beam.elements.tcl\" set tstag 1 timeSeries Linear $tstag 1.0 set Ly 0.5 set Ny 5 set dy [expr $Ly / $Ny ] set fx [expr 0 * $dy / 2 ] set fy [expr - 10 . * $dy / 2 ] pattern Plain 1 \"Linear\" { source \"beam.loads.tcl\" } recorder pvd disp disp constraints Plain numberer RCM system UmfPack test NormDispIncr 1.0 e-9 10 algorithm Newton integrator LoadControl 1 analysis Static analyze 1 The pvd recorder is used to generate a nice output file that can be viewed using paraview .","tags":"misc","url":"https://joseabell.com/posts/2018/using-my-gmshtranslator-python-tool-to-interface-gmsh-with-opensees.html","loc":"https://joseabell.com/posts/2018/using-my-gmshtranslator-python-tool-to-interface-gmsh-with-opensees.html"},{"title":"Paper03 - Earthquake Soil Structure Interaction of Nuclear Power Plants, differences in response to 3-D, 3 × 1-D, and 1-D excitations","text":"Finally! First paper since PhD was accepted for publication. I'll take this opportunity to start a tradition and review my own papers here. I think its important that I do this for several reasons. First, there are discussions that come up during peer review that are important but don't make it into the paper. Misconceptions about the presented work can be clarified to a broader audience here. Also, I can say whatever I want, specially opinions and thoughts that come from intuition and might not make it through peer-review, I'll be as critical as possible about these too and hope that my readers can discuss with me. I can post videos and other additional content here and make them available to everyone for free. And, finally, this post will have a Disqus thread Lets get to it! Here is the citation so far (I still don't have an issue assign, going through editorial process): Abell Mena J A , Orbović N, McCallen D B, Jeremic B. Earthquake soil-structure interaction of nuclear power plants, differences in response to 3-D, 3×1-D, and 1-D excitations. Earthquake Engng Struct Dyn. 2018;1–18. [https://doi.org/10.1002/eqe.3026]. The idea is simple: to show that the 3-D character of seismic motions has an impact on the structural response of a nuclear power-plant by comparing the response to 3-D motions with the one produced by an equivalent 1-D (1 component: horizontal) or 3×1-D (3 components) motion. Here is the NPP model used in the article: And its fixed-base eigenmodes: I was required by the peer-reviewers to include these fixed-base modes in the article. These are interesting, but they're not too relevant to the SSI system. SSI significantly changes the participation of the modes. I've found it useful to stop thinking in terms of eigen modes for these kind of problems, it is better to think in terms of the requirements of wave-propagation. In the paper, I use the domain reduction method (DRM) to couple a 3-D seismic simulation of the wave propagation from source to site with a local site and structure model. This domain split allows the fully 3-D modeling of the motions into the structure, accurately. Also, importantly, it allows the separation of the seismic and NPP simulation, using separate dedicated programs for each task as opposed to one big complex simulation. This reduces the computational cost dramatically and allows more modeling freedom. From the free-field response of the site (e.g. with no NPP on top) equivalent 1-D and 3×1-D motions were developed using 1-D site deconvolutions in Shake and input into the model for comparison. Here's a plot of what the differences look like for the top of the containment building. 1-D or 3×1-D waves deliver energy in-phase to the foundation of the structure, resulting in enhanced response when compared to a full 3-D response. In this particular case, it would be conservative (looking at response accelerations and displacements) to use 1-D modeling of the seismic input. But, here is a point that couldn't be made in the article, this depends on the system and I have found cases where the results are opposite: it is nonconservative to ignore 3-D ground motions effects. This point needs to be made more clearly (future work), for different seismic settings and structures. I also ran this model using a non-linear constitutive model for the soil. Check out what the energy dissipation looks like under the NPP (not part of the paper). This was submitted for review Jan 6 2017, it took over a year to get acceptance! Three iterations of peer-review were done. Admittedly, I did take too much time to answer. Tough year was 2017. Although the reviewers were very picky, which led to article improvement--especially the introduction--, the main content of the article changed little. We have the same results and conclusions. Where from here? It think DRM-based SSI analysis is the methodology to produce the highest-possible fidelity modeling of SSI. But generating these DRM motions is costly, we need supercomputers for that. Highly-detailed modeling of seismic motions is currently underway, it would be rather cheap for the researchers doing these simulations to also generate DRM-compatible motions for future exploration, making these simulations even more relevant. There needs to be an agreed format for the distribution of DRM motions, and a repository of validated motions to be used for modeling. Is it worthwhile? That's a research question in of itself. Clearly we can build to withstand earthquakes, so its not a safety-critical issue to use advanced SSI modeling. Might be an economic one. Maybe some case-studies can be reinterpreted in the light of 3-D motions to suggest that they were to blame in unexpected performance of existing infrastructure. Some structures will be more sensitive to these effects than others, which? how much so? under what conditions? is it necessary to model them in this way? There is great value in high-fidelity SSI modeling, is there a way to bring this into practice? All questions I want to answer in the years to come.","tags":"misc","url":"https://joseabell.com/posts/2018/paper03-earthquake-soil-structure-interaction-of-nuclear-power-plants-differences-in-response-to-3-d-3-1-d-and-1-d-excitations.html","loc":"https://joseabell.com/posts/2018/paper03-earthquake-soil-structure-interaction-of-nuclear-power-plants-differences-in-response-to-3-d-3-1-d-and-1-d-excitations.html"},{"title":"Video of 2-D SSI model of an RC Shear Wall Building","text":"The RC shear-wall building is modeled in OpenSees using non-linear fiber based beam column elements. Soil is modeled as a continuum using quad elements and linear stress-strain relationship. Soil shear wave-speed is varied in depth such as to obtain a \\(V_{s30}\\) consistent with a class B site according to chilean seismic code. Lysmer-Kulhemeyer dashpots are used along the soil boundary to model seismic radiation and earthquake wave-field input. The performance of the building will be assessed for varying site fundamental periods. This is an aspect of SSI that is not covered by the chilean seismic code, and has been shown to be a problem in past earthquakes. This is part of an on-going study with Prof. Carolina Magna from Adolfo Ibañez Unversity and her MS student Miguel Ángel Rodriguez from UDP.","tags":"misc","url":"https://joseabell.com/posts/2017/video-of-2-d-ssi-model-of-an-rc-shear-wall-building.html","loc":"https://joseabell.com/posts/2017/video-of-2-d-ssi-model-of-an-rc-shear-wall-building.html"},{"title":"New cable element in OpenSees","text":"With my student, Pablo Ibañez, we implemented a new catenary cable element in OpenSees. This element is based on the work by Salehi et al[1]. The stiffness of this element is obtained using a flexibility formulation. Basically the shape of the cable is determined by the integral: $$ \\newcommand{\\pare}[1]{\\left( #1 \\right)} \\newcommand{\\brak}[1]{\\left[ #1 \\right]} \\newcommand{\\brac}[1]{\\left\\lbrace #1 \\right\\rbrace} \\newcommand{\\vect}[1]{\\boldsymbol{#1}} \\newcommand{\\uv}[1]{\\hat{\\boldsymbol{#1}}} \\newcommand{\\ud}{\\,\\mathrm{d}} \\begin{align*} \\vect{x}(s) = \\vect{x}_1 - \\int_0&#94;s \\dfrac{\\vect{w}s + \\vect{f}}{\\Vert \\vect{w}s + \\vect{f} \\Vert&#94;2}\\pare{\\dfrac{\\Vert \\vect{w}s + \\vect{f} \\Vert}{EA} + \\pare{1 + \\alpha \\Delta T}} \\ud s \\\\ \\vect{w} = \\brak{w_1,\\, w_2,\\, w_3}&#94;T \\qquad \\vect{f} = \\brak{f_1,\\, f_2,\\, f_3}&#94;T \\end{align*} $$ Where \\(\\vect{x_1}\\) is the position of the first node of the cable, \\(\\vect{w}\\) is the weight vector in each direction, \\(EA\\) is the stiffness, \\(\\alpha \\Delta T\\) is the change in strain due to temperature and \\(\\vect{f}\\) is the force vector at the start node. This equation is iterated (with the forces as variable) upon until the the shape of the cable matches the nodal postiions imposed by the finite element program (trial displacements). Then it is used to derive a stiffness matrix. The element, as is, passes all our static verification tests. With the additional assumption of a lumped-mass matrix, we're currently working on a dynamic verification suite as well as some validation experiments. The animation above was created using OpenSees to simulate the cable and Blender to render it. Reference [1] Salehi Ahmad Abad, M., Shooshtari, A., Esmaeili, V., & Naghavi Riabi, A. (2013). Nonlinear analysis of cable structures under general loadings. Finite Elements in Analysis and Design, 73, 11–19. https://doi.org/10.1016/j.finel.2013.05.002","tags":"Coding","url":"https://joseabell.com/posts/2017/new-cable-element-in-opensees.html","loc":"https://joseabell.com/posts/2017/new-cable-element-in-opensees.html"},{"title":"OpenSees coming to python!","text":"One of the gripes a lot of people have with OpenSees is that it adopts TCL as its interpreter language. Originally, OpenSees was conceived as a framework , this is apparent from the main page of the wiki : OpenSees, the Open System for Earthquake Engineering Simulation, is an object-oriented, open source software framework. It allows users to create both serial and parallel finite element computer applications for simulating... So, it was meant to be a neat way to build new FEM software. For years the only actual (known) application to use the OpenSees framework was what came to be known as OpenSees proper, a TCL interpreter extended with OpenSees modeling commands. Talking with Frank McKenna, the mind behind OpenSees, this stemmed from then need to show an actual application which could demonstrate the idea of the OpenSees framework in a quick and dirty way. The vision was that people would get the OpenSees source and build new and exciting finite-element software. It was \"up to the skills of the user\", like the main wiki page still reads. Sadly, civil engineers are not very code-savvy and no (useful) new applications came. Therefore it came to pass that the OpenSees extension of the TCL interpreter became OpenSees and this is what everyone uses. Now TCL is an awkward language for a scientific application, mainly due to syntax and lack of a complete library for scientific computing. Python, on the other hand, has proven in the recent years to be a worthy replacement of the mighty Matlab. Many of us started scientific computing in Matlab and then migrated to the free world of Python. It was just logical that OpenSees would benefit much more from using Python as its language of choice rather than TCL. It has finally happened, and this blog post celebrates my joy. Behold the following analysis case written in Python. import opensees as ops ops . wipe () ops . model ( 'basic' , '-ndm' , 3 , '-ndf' , 3 ) for e in range ( 3 ): ops . node ( 1 + 4 * e , 0. , 0. , 1. * e ) ops . node ( 2 + 4 * e , 1. , 0. , 1. * e ) ops . node ( 3 + 4 * e , 1. , 1. , 1. * e ) ops . node ( 4 + 4 * e , 0. , 1. , 1. * e ) ops . fix ( 1 , 1 , 1 , 1 ) ops . fix ( 2 , 1 , 1 , 1 ) ops . fix ( 3 , 1 , 1 , 1 ) ops . fix ( 4 , 1 , 1 , 1 ) ops . nDMaterial ( \"ElasticIsotropic3D\" , 1 , 2100. , 0.3 , 0.0 ) ops . element ( \"stdBrick\" , 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ) ops . element ( \"stdBrick\" , 2 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 1 ) ops . timeSeries ( \"Linear\" , 1 ) ops . pattern ( \"Plain\" , 1 , 1 , \"-fact\" , 1.0 ) ops . load ( 1 + 4 * e , 0. , 0. , - 50. ) # Load at the first of the top nodes. ops . system ( \"BandSPD\" ) ops . numberer ( \"RCM\" ) ops . constraints ( \"Plain\" ) ops . algorithm ( \"Linear\" ) ops . integrator ( \"LoadControl\" , 1.0 ) ops . analysis ( \"Static\" ) ops . analyze ( 1 ) This example just stacks two bricks and applies a downward load on one of the top nodes. The interesting part is that now you can interact with all of the rich tools available in python. Just as a taste of what's to come, here is a plot of the deformed shape of the example above created using matplotlib's 3-D plotting capabilities. And here's the code that achieves this: ### Plot bricks in the domain import scipy as sp import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt . figure () ax = fig . add_subplot ( 111 , projection = '3d' ) for e in ops . getEleTags (): nodes = ops . eleNodes ( e ) Nnodes = len ( nodes ) xyz = sp . zeros (( Nnodes , 3 ), dtype = sp . double ) uu = sp . zeros (( Nnodes , 3 ), dtype = sp . double ) for i in range ( Nnodes ): xyz [ i ,:] = ops . nodeCoord ( nodes [ i ]) uu [ i ,:] = ops . nodeDisp ( nodes [ i ]) print x = sp . zeros ( 12 , dtype = sp . double ) y = sp . zeros ( 12 , dtype = sp . double ) z = sp . zeros ( 12 , dtype = sp . double ) u = sp . zeros ( 12 , dtype = sp . double ) v = sp . zeros ( 12 , dtype = sp . double ) w = sp . zeros ( 12 , dtype = sp . double ) conec = [ 0 , 1 , - 1 , \\ 1 , 2 , - 1 , \\ 2 , 3 , - 1 , \\ 3 , 0 , - 1 , \\ 4 , 5 , - 1 , \\ 5 , 6 , - 1 , \\ 6 , 7 , - 1 , \\ 7 , 4 , - 1 , \\ 0 , 4 , - 1 , \\ 1 , 5 , - 1 , \\ 2 , 6 , - 1 , \\ 3 , 7 ] x = xyz [ conec , 0 ] y = xyz [ conec , 1 ] z = xyz [ conec , 2 ] x [ 2 :: 3 ] = sp . nan y [ 2 :: 3 ] = sp . nan z [ 2 :: 3 ] = sp . nan factor = 1. u = xyz [ conec , 0 ] + factor * uu [ conec , 0 ] v = xyz [ conec , 1 ] + factor * uu [ conec , 1 ] w = xyz [ conec , 2 ] + factor * uu [ conec , 2 ] u [ 2 :: 3 ] = sp . nan v [ 2 :: 3 ] = sp . nan w [ 2 :: 3 ] = sp . nan ax . plot ( x , y , z , \"-ob\" ) ax . plot ( u , v , w , \"-or\" ) plt . show () A simple extension to the above example generalizes the stack to an arbitrary number of bricks. And the visualization just works. Currently, I have to manually compile a python module extension on my Ubuntu linux laptop for this to work. I have no idea if it will be available to windows users as an easy-to-download binary in the near future. I will post on how to get this working on linux though. For those of you adventurous enough.","tags":"Blog","url":"https://joseabell.com/posts/2017/opensees-coming-to-python.html","loc":"https://joseabell.com/posts/2017/opensees-coming-to-python.html"},{"title":"Finite Elements for Shallow Water Equations","text":"$$ \\newcommand{\\pare}[1]{\\left( #1 \\right)} \\newcommand{\\brak}[1]{\\left[ #1 \\right]} \\newcommand{\\brac}[1]{\\left\\lbrace #1 \\right\\rbrace} \\newcommand{\\absol}[1]{\\left\\vert #1 \\right\\vert} \\newcommand{\\overbar}[1]{\\mkern 1.5mu\\overline{\\mkern-1.5mu#1\\mkern-1.5mu}\\mkern 1.5mu} \\newcommand{\\EE}[1]{\\times 10&#94;{#1}} \\newcommand{\\eqand}{\\, \\text{and} \\,} \\newcommand{\\qeqand}{\\quad \\text{and} \\quad} \\newcommand{\\qqeqand}{\\qquad \\text{and} \\qquad} \\newcommand{\\HRule}{\\rule{\\linewidth}{0.2mm}} \\newcommand{\\vect}[1]{\\boldsymbol{#1}} \\newcommand{\\uv}[1]{\\hat{\\boldsymbol{#1}}} \\newcommand{\\ud}{\\,\\mathrm{d}} \\newcommand{\\matorvec}[2]{\\left[\\begin{array}{#1} #2\\end{array}\\right]} \\newcommand{\\pardiff}[2]{\\dfrac{\\partial\\, #1}{\\partial\\, #2}} \\newcommand{\\pp}[2]{\\frac{\\partial #1}{\\partial #2}} \\newcommand{\\totdiff}[2]{\\dfrac{\\ud #1}{\\ud #2}} \\newcommand{\\rint}{\\pare{R}\\hspace{-0.5em} \\int } \\newcommand{\\expon}[1]{\\exp \\left\\lbrace #1 \\right\\rbrace} \\newcommand{\\unit}[1]{ \\, \\mathrm{#1} } \\newcommand{\\bunit}[1]{ \\, \\left[ \\mathrm{#1} \\right] } \\newcommand{\\funit}[2]{ \\, \\mathrm{ \\frac{#1}{#2} } } \\newcommand{\\bfunit}[2]{ \\, \\left[ \\mathrm{ {#1}/{#2} } \\right] } \\newcommand{\\mts}{\\bunit{m}} \\newcommand{\\cmts}{\\bunit{cm}} \\newcommand{\\mmts}{\\bunit{mm}} \\newcommand{\\kmts}{\\bunit{km}} \\newcommand{\\mps}{\\bfunit{m}{s}} \\newcommand{\\cmpt}{\\bfunit{cm}{s}} \\newcommand{\\mmps}{\\bfunit{mm}{s}} \\newcommand{\\kmps}{\\bfunit{km}{s}} \\newcommand{\\Newt}{\\bunit{N}} \\newcommand{\\kNewt}{\\bunit{kN}} \\newcommand{\\MNewt}{\\bunit{MN}} \\newcommand{\\Pa}{\\bunit{Pa}} \\newcommand{\\kPa}{\\bunit{kPa}} \\newcommand{\\MPa}{\\bunit{MPa}} \\newcommand{\\GPa}{\\bunit{GPa}} \\newcommand{\\kNmm}{\\bfunit{kN}{m&#94;2}} \\newcommand{\\Nmm}{\\bfunit{N}{m&#94;2}} \\newcommand{\\kgmmm}{\\bfunit{kg}{m&#94;3}} \\newcommand{\\Mgmmm}{\\bfunit{Mg}{m&#94;3}} \\newcommand{\\grcmcmcm}{\\bfunit{g}{cm&#94;3}} \\newcommand{\\kNmmm}{\\bfunit{kN}{m&#94;3}} \\newcommand{\\gr}{\\bunit{g}} \\newcommand{\\mgr}{\\bunit{mg}} \\newcommand{\\kgr}{\\bunit{kg}} \\newcommand{\\Mgr}{\\bunit{Mg}} \\newcommand{\\seg}{\\bunit{s}} \\newcommand{\\msec}{\\bunit{ms}} \\newcommand{\\musec}{\\bunit{\\mu s}} \\newcommand{\\mo}{\\bunit{month}} \\newcommand{\\mos}{\\bunit{months}} \\newcommand{\\days}{\\bunit{days}} \\newcommand{\\gs}{\\bunit{g}} \\newcommand{\\mss}{\\bfunit{m}{s&#94;2}} \\newcommand{\\cmss}{\\bfunit{cm}{s&#94;2}} \\newcommand{\\Hz}{\\bunit{Hz}} \\newcommand{\\MHz}{\\bunit{MHz}} \\newcommand{\\GHz}{\\bunit{GHz}} \\newcommand{\\THz}{\\bunit{THz}} \\newcommand{\\dgr}{\\unit{&#94;{\\circ}}} \\newcommand{\\rads}{\\bunit{rad}} \\newcommand{\\kips}{\\unit{kips}} \\newcommand{\\ksi}{\\unit{ksi}} \\newcommand{\\inch}{\\unit{in}} $$ The linear shallow water equations (SWE) are used extensively to model propagation of waves in situations where lateral domain dimensions are much greater than fluid height and, at the same time, wave perturbation height are much smaller than the fluid height. This finds useful applications in the case of tsunami-wave propagation modeling in deep-sea. The equations, after heavy linearization, are given by: $$\\begin{aligned} \\pardiff{u}{t} - f v = -g \\pardiff{h}{x} \\\\ \\pardiff{v}{t} + f v = -g \\pardiff{h}{y} \\\\ \\pardiff{h}{t} = -H \\pare{ \\pardiff{u}{x} + \\pardiff{v}{y} }\\end{aligned}$$ Where \\(u\\) is the speed in \\(x\\) direction. \\(v\\) is the speed in \\(y\\) direction. \\(h\\) wave perturbation height. (Free surface is at \\(h+H\\) ) \\(f\\) Coriolis force, given by: $$\\begin{aligned} f = 2 \\Omega \\sin \\phi \\end{aligned}$$ where \\(\\Omega\\) is Earth's angular velocity ( \\(\\pi/12 \\, \\brak{\\mathrm{rad/h}}\\) ) and \\(\\phi\\) is latitude. \\(g\\) acceleration due to gravity at given point in Earth. \\(H\\) fluid free surface height at repose. To complete the formulation, appropriate boundary conditions are needed. These equations will be discretized using Galerkin finite-element formulation. For this purpose we will be using the first order triangle finite element (see Felippa's chapter 15 here for basic notation and details regarding triangular shape functions). The SWE represent the space-time evolution of three scalar fields, namely \\(h\\) , \\(u\\) , and \\(v\\) . These three independent variables are the 3 degrees-of-freedom (DOF) of the problem. Therefore, each node will have information about these three DOFs. Using the basic 3-node triangle with interpolation functions given by the triangular coordinates (see Felippa IFEM Ch. 15 and this for more info), these fields are interpolated as follows. $$\\begin{aligned} h = \\sum N_i h_i = \\vect{N} \\vect{h} = \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\matorvec{c}{h_1\\\\h_2\\\\h_3} \\\\ u = \\sum N_i u_i = \\vect{N} \\vect{u} = \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\matorvec{c}{u_1\\\\u_2\\\\u_3} \\\\ v = \\sum N_i v_i = \\vect{N} \\vect{v} = \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\matorvec{c}{v_1\\\\v_2\\\\v_3} \\end{aligned}$$ Where \\(\\zeta_i\\) are triangular coordinates and \\(u_i\\) , \\(v_i\\) , and \\(h_i\\) the nodal values of the scalar fields at node \\(i\\) . As typical, we multiply the equations by a trial shape function \\(N_j\\) and integrate over the domain of the element \\(\\Omega&#94;e\\) , carrying out integration by parts. We arrive at the weak form of the SWE. $$\\begin{aligned} \\pare{ \\int_{\\Omega&#94;e} N_i N_j \\ud \\Omega&#94;e} \\dot{h}_j - \\pare{ \\int_{\\Omega&#94;e} H \\pardiff{N_i}{x} N_j \\ud \\Omega&#94;e} u_j - \\pare{ \\int_{\\Omega&#94;e} H \\pardiff{N_i}{y} N_j \\ud \\Omega&#94;e} v_j = 0 \\\\ \\pare{ \\int_{\\Omega&#94;e} N_i N_j \\ud \\Omega&#94;e} \\dot{u}_j - \\pare{ \\int_{\\Omega&#94;e} f N_i N_j \\ud \\Omega&#94;e} v_j + \\pare{ \\int_{\\Omega&#94;e} g N_i \\pardiff{N_j}{x} \\ud \\Omega&#94;e} h_j = 0 \\\\ \\pare{ \\int_{\\Omega&#94;e} N_i N_j \\ud \\Omega&#94;e} \\dot{v}_j + \\pare{ \\int_{\\Omega&#94;e} f N_i N_j \\ud \\Omega&#94;e} u_j + \\pare{ \\int_{\\Omega&#94;e} g N_i \\pardiff{N_j}{y} \\ud \\Omega&#94;e} h_j = 0 \\end{aligned}$$ Here, for the first order triangle, we simply have that 1 \\(N_i = \\zeta_i\\) . Defining the vector of nodal freedoms \\(\\vect{z}\\) as: $$\\begin{aligned} \\vect{z}&#94;T = \\matorvec{ccccccccc}{h_1 & h_2 & h_3 & u_1 & u_2 & u_3 & v_1 & v_2 & v_3 }&#94;T\\end{aligned}$$ The above equations can be re-written as follows: $$\\begin{aligned} \\matorvec{ccc} { \\vect{M} & \\vect{0} & \\vect{0} \\\\ \\vect{0} & \\vect{M} & \\vect{0} \\\\ \\vect{0} & \\vect{0} & \\vect{M} } \\dot{\\vect{z}} + \\matorvec{ccc} { \\vect{0} & -\\vect{K}_{hu} & -\\vect{K}_{hv} \\\\ \\vect{K}_{uh} & \\vect{0} & -\\vect{K}_{uv} \\\\ \\vect{K}_{vh} & \\vect{K}_{vu} & \\vect{0} } \\vect{z} = \\matorvec{c} { \\vect{0} \\\\ \\vect{0} \\\\ \\vect{0} } \\\\ \\vect{A} \\dot{\\vect{z}} + \\vect{B} \\vect{z} = \\vect{0}\\end{aligned}$$ Where the involved sub-matrices are given by the following matrix integrals: $$\\begin{aligned} & \\vect{M} = \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{hu} = \\int_{\\Omega&#94;e} H \\pare{\\pardiff{\\vect{N}}{x}}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{hv} = \\int_{\\Omega&#94;e} H \\pare{\\pardiff{\\vect{N}}{y}}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{uh} = \\int_{\\Omega&#94;e} g \\vect{N}&#94;T \\pardiff{\\vect{N}}{x} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{vh} = \\int_{\\Omega&#94;e} g \\vect{N}&#94;T \\pardiff{\\vect{N}}{y} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{uv} = \\int_{\\Omega&#94;e} f \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ & \\vect{K}_{vu} = \\int_{\\Omega&#94;e} f \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\end{aligned}$$ The derivatives \\(\\pardiff{\\vect{N}}{x}\\) y \\(\\pardiff{\\vect{N}}{y}\\) can be evaluated component-wise (again, see Felippa's work): $$\\begin{aligned} \\matorvec{c} { \\pardiff{N_i}{x} \\\\ \\pardiff{N_i}{y} } = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ x_{32} & x_{13} & x_{21} } \\matorvec{c} { \\pardiff{N_i}{\\zeta_1} \\\\ \\pardiff{N_i}{\\zeta_2} \\\\ \\pardiff{N_i}{\\zeta_3} }\\end{aligned}$$ For example, for \\(N_1\\) : $$\\begin{aligned} \\matorvec{c} { \\pardiff{N_1}{x} \\\\ \\pardiff{N_1}{y} } = \\matorvec{c} { \\pardiff{\\zeta_1}{x} \\\\ \\pardiff{\\zeta_1}{y} } = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ x_{32} & x_{13} & x_{21} } \\matorvec{c} { \\pardiff{\\zeta_1}{\\zeta_1} \\\\ \\pardiff{\\zeta_1}{\\zeta_2} \\\\ \\pardiff{\\zeta_1}{\\zeta_3} } = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ x_{32} & x_{13} & x_{21} } \\matorvec{c} { 1 \\\\ 0 \\\\ 0 } = \\dfrac{1}{2A} \\matorvec{c} { y_{23} \\\\ x_{32} }\\end{aligned}$$ It is clear that, therefore $$\\begin{aligned} \\pardiff{\\vect{N}}{x} = \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} } \\\\ \\pardiff{\\vect{N}}{y} = \\dfrac{1}{2A} \\matorvec{ccc} { x_{32} & x_{13} & x_{21} }\\end{aligned}$$ Note that these derivatives are constant within each trinagle (hence the name, constant strain triangle although the interpretation is not strain in this case). In this context we have that \\(x_{ij} = x_i - x_j\\) where \\(x_i\\) is the \\(x\\) coordinate of the \\(i\\) -th element node. Similarly for \\(y_{ij} = y_i - y_j\\) . If we further assume that the gravity field \\(g\\) , the local depth at the finite element and the Coriolis force \\(f\\) are constant (probably a bad assumption for this variable for some applications which span the globe) within an element we can further reduce the discretized equations to: $$\\begin{aligned} \\vect{I}_{1} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\vect{N} \\ud \\Omega&#94;e \\\\ \\vect{I}_{2} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{x} \\ud \\Omega&#94;e \\\\ \\vect{I}_{3} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{y} \\ud \\Omega&#94;e\\end{aligned}$$ Working on the first integral $$\\begin{aligned} \\vect{I}_1 &= \\int_{\\Omega&#94;e} \\matorvec{c}{ \\zeta_1 \\\\ \\zeta_2 \\\\ \\zeta_3 } \\matorvec{ccc}{ \\zeta_1 & \\zeta_2 & \\zeta_3 } \\ud \\Omega&#94;e\\\\ &= \\int_{\\Omega&#94;e} \\matorvec{ccc} { {\\zeta_1}&#94;2 & \\zeta_2\\zeta_1 & \\zeta_3 \\zeta_1 \\\\ \\zeta_1\\zeta_2 & {\\zeta_2}&#94;2 & \\zeta_3\\zeta_2 \\\\ \\zeta_1\\zeta_3 & \\zeta_2\\zeta_3 & {\\zeta_3}&#94;2 \\\\ } \\ud \\Omega&#94;e \\end{aligned}$$ We can use the following formula for the integration within a triangle of the monomials (again, from here ) $$\\begin{aligned} \\int_{\\Omega&#94;e} {\\zeta_1}&#94;p{\\zeta_2}&#94;q{\\zeta_2}&#94;r \\ud \\Omega&#94;e = \\dfrac{2 A p!\\, q!\\, r!}{\\pare{p+q+r+2}!}\\end{aligned}$$ With this, the integral for \\(\\vect{I}_1\\) is evaluated to $$\\begin{aligned} \\vect{I}_1 = \\dfrac{A}{12} \\matorvec{ccc} { 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 } \\end{aligned}$$ Proceeding with the next integral: $$\\begin{aligned} \\vect{I}_{2} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{x} \\ud \\Omega&#94;e \\\\ &= \\int_{\\Omega&#94;e} \\matorvec{c}{ \\zeta_1 \\\\ \\zeta_2 \\\\ \\zeta_3 } \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} } \\ud \\Omega&#94;e = \\int_{\\Omega&#94;e} \\matorvec{c}{ \\zeta_1 \\\\ \\zeta_2 \\\\ \\zeta_3 } \\ud \\Omega&#94;e \\cdot \\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} }\\\\ \\end{aligned}$$ Utilizing the same identity as before to evaluate the integrals we arrive at: $$\\begin{aligned} \\vect{I}_2 = \\dfrac{A}{3} \\matorvec{c}{ 1 \\\\ 1 \\\\ 1 }\\dfrac{1}{2A} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} } = \\dfrac{1}{6} \\matorvec{ccc} { y_{23} & y_{31} & y_{12} \\\\ y_{23} & y_{31} & y_{12} \\\\ y_{23} & y_{31} & y_{12} }\\end{aligned}$$ Analogously for \\(\\vect{I}_3\\) we have: $$\\begin{aligned} \\vect{I}_{3} &= \\int_{\\Omega&#94;e} \\vect{N}&#94;T \\pardiff{\\vect{N}}{y} \\ud \\Omega&#94;e = \\dfrac{1}{6} \\matorvec{ccc} { x_{32} & x_{13} & x_{21} \\\\ x_{32} & x_{13} & x_{21} \\\\ x_{32} & x_{13} & x_{21} }\\end{aligned}$$ And finally we can write the sub-matrices as follows. $$\\begin{aligned} \\vect{M} &= \\vect{I}_1 \\\\ \\vect{K}_{hu} &= H \\cdot {\\vect{I}_2}&#94;T & \\vect{K}_{hv} &= H \\cdot {\\vect{I}_3}&#94;T \\\\ \\vect{K}_{uh} &= g \\cdot \\vect{I}_2 & \\vect{K}_{vh} &= g \\cdot \\vect{I}_3 \\\\ \\vect{K}_{uv} &= f \\cdot \\vect{I}_1 & \\vect{K}_{vu} &= f \\cdot \\vect{I}_1 \\end{aligned}$$ Which can be replaced into $$\\begin{aligned} \\matorvec{ccc} { \\vect{M} & \\vect{0} & \\vect{0} \\\\ \\vect{0} & \\vect{M} & \\vect{0} \\\\ \\vect{0} & \\vect{0} & \\vect{M} } \\dot{\\vect{z}} + \\matorvec{ccc} { \\vect{0} & -\\vect{K}_{hu} & -\\vect{K}_{hv} \\\\ \\vect{K}_{uh} & \\vect{0} & -\\vect{K}_{uv} \\\\ \\vect{K}_{vh} & \\vect{K}_{vu} & \\vect{0} } \\vect{z} = \\matorvec{c} { \\vect{0} \\\\ \\vect{0} \\\\ \\vect{0} } \\\\ \\vect{A} \\dot{\\vect{z}} + \\vect{B} \\vect{z} = \\vect{0}\\end{aligned}$$ to generate the discretized SWE. A future post will discuss the python implementation of this finite element and its application to a basic problem.","tags":"Finite elements","url":"https://joseabell.com/posts/2016/finite-elements-for-shallow-water-equations.html","loc":"https://joseabell.com/posts/2016/finite-elements-for-shallow-water-equations.html"},{"title":"Talk Given at IngeoKring 2016 - Physics-Based Earthquake-Soil-Structure Interaction for Near-Field Induced Seismicity","text":"This is a talk given at the IngeoKring 2016 Autumn symposium, hosted at TU Delft.","tags":"Talks","url":"https://joseabell.com/posts/2016/talk-given-at-ingeokring-2016-ESSI-DRM.html","loc":"https://joseabell.com/posts/2016/talk-given-at-ingeokring-2016-ESSI-DRM.html"},{"title":"Simulation of a surface wave (Rayleigh)","text":"This simulation, done in the UCD ESSI simulator and visualized in VisIt using VisIt-ESSI plugin, shows the passage of a surface wave (Rayleigh wave). The simulation consists on a surface impact on an elastic domain of 900m by 1800m depth, and a shear wave velocity of 1000km/s. Elliptical-retrograde motion can be seen as an illustration of Rayleigh waves. VisIt can be obtained here , and the plugin here .","tags":"misc","url":"https://joseabell.com/simulation-of-a-surface-wave-English.html","loc":"https://joseabell.com/simulation-of-a-surface-wave-English.html"},{"title":"Visualizing ESSI output with VisIt-ESSI","text":"VisIt-ESSI is a plugin for the VisIt post-processor created my CompGeoMech. It allows for remote (soon parallel also) visualization of outputs produced by ESSI in the HDF5 format (*.h5.feioutput). VisIt can be obtained here , and the plugin here .","tags":"misc","url":"https://joseabell.com/visualizing-essi-output-with-visit-essi-English.html","loc":"https://joseabell.com/visualizing-essi-output-with-visit-essi-English.html"}]};